<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="16.friend友元类和友元函数 能访问私有成员 破坏封装性 友元关系不可传递 友元关系的单向性 友元声明的形式及数量不受限制">
<meta property="og:type" content="article">
<meta property="og:title" content="interview2">
<meta property="og:url" content="http://yoursite.com/2020/05/11/interview2/index.html">
<meta property="og:site_name" content="Mark&#39;s Blog">
<meta property="og:description" content="16.friend友元类和友元函数 能访问私有成员 破坏封装性 友元关系不可传递 友元关系的单向性 友元声明的形式及数量不受限制">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-05-11T03:14:57.802Z">
<meta property="article:modified_time" content="2020-05-11T10:14:08.625Z">
<meta property="article:author" content="Mark">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/05/11/interview2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>interview2 | Mark's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mark's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">其实你我都一样，终将被遗忘</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/11/interview2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Mark">
      <meta itemprop="description" content="cv小学生，不擅长c++，python，机器学习，深度学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mark's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          interview2
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-11 11:14:57 / 修改时间：18:14:08" itemprop="dateCreated datePublished" datetime="2020-05-11T11:14:57+08:00">2020-05-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="16-friend友元类和友元函数"><a href="#16-friend友元类和友元函数" class="headerlink" title="16.friend友元类和友元函数"></a>16.friend友元类和友元函数</h1><ul>
<li>能访问私有成员</li>
<li>破坏封装性</li>
<li>友元关系不可传递</li>
<li>友元关系的单向性</li>
<li>友元声明的形式及数量不受限制</li>
</ul>
<a id="more"></a>

<h1 id="17-using"><a href="#17-using" class="headerlink" title="17.using"></a>17.using</h1><h2 id="using声明"><a href="#using声明" class="headerlink" title="using声明"></a>using声明</h2><p>一条 using 声明 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> namespace_name::name;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数的using声明"><a href="#构造函数的using声明" class="headerlink" title="构造函数的using声明"></a>构造函数的using声明</h2><p>在 C++11 中，派生类能够重用其直接基类定义的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Derived(parms) : Base(args) &#123; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="using指示"><a href="#using指示" class="headerlink" title="using指示"></a>using指示</h2><p>using 指示 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> namespace_name name;</span><br></pre></td></tr></table></figure>

<h2 id="尽量少使用-using-指示-污染命名空间"><a href="#尽量少使用-using-指示-污染命名空间" class="headerlink" title="尽量少使用 using 指示 污染命名空间"></a>尽量少使用 using 指示 污染命名空间</h2><p>一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它只导入了指定的名称。如果该名称与局部名称发生冲突，编译器将发出指示。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p>
<p>using使用</p>
<p>尽量少使用 using 指示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>

<p>应该多使用 using 声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x ;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<h1 id="18-范围解析运算符"><a href="#18-范围解析运算符" class="headerlink" title="18.::范围解析运算符"></a>18.::范围解析运算符</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol>
<li>全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li>
<li>类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的</li>
<li>命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的</li>
</ol>
<p>:: 使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;        <span class="comment">// 全局（::）的 count</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count; <span class="comment">// 类 A 的 count（A::count）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ::count = <span class="number">1</span>;      <span class="comment">// 设置全局的 count 的值为 1</span></span><br><span class="line"></span><br><span class="line">    A::count = <span class="number">2</span>;     <span class="comment">// 设置类 A 的 count 为 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;    <span class="comment">// 局部的 count</span></span><br><span class="line">    count = <span class="number">3</span>;        <span class="comment">// 设置局部的 count 的值为 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="19-enum枚举类型"><a href="#19-enum枚举类型" class="headerlink" title="19.enum枚举类型"></a>19.enum枚举类型</h1><h2 id="限定作用域的枚举类型"><a href="#限定作用域的枚举类型" class="headerlink" title="限定作用域的枚举类型"></a>限定作用域的枚举类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">open_modes</span> &#123;</span>input,output,append&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="不限定作用域的枚举类型"><a href="#不限定作用域的枚举类型" class="headerlink" title="不限定作用域的枚举类型"></a>不限定作用域的枚举类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> color &#123;red,yellow,green&#125;;</span><br><span class="line"><span class="keyword">enum</span> &#123;floatPrec=<span class="number">6</span>,doublePrec=<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="20-decltype"><a href="#20-decltype" class="headerlink" title="20.decltype"></a>20.decltype</h1><p>decltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span> ( expression )</span><br></pre></td></tr></table></figure>

<p>decltype 使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾置返回允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn(It beg, It end) -&gt; decltype(*beg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;    <span class="comment">// 返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为了使用模板参数成员，必须用 typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;    <span class="comment">// 返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="21-引用"><a href="#21-引用" class="headerlink" title="21.引用"></a>21.引用</h1><h2 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h2><p>常规引用，一般表示对象的身份。</p>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。</p>
<p>右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：</p>
<ul>
<li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li>
<li>能够更简洁明确地定义泛型函数。</li>
</ul>
<h2 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h2><ul>
<li>X&amp; &amp;、X&amp; &amp;&amp;、X&amp;&amp; &amp; 可折叠成 X&amp;</li>
<li>X&amp;&amp; &amp;&amp; 可折叠成 X&amp;&amp;</li>
</ul>
<h1 id="22-宏"><a href="#22-宏" class="headerlink" title="22.宏"></a>22.宏</h1><ul>
<li>宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。</li>
</ul>
<h1 id="23-成员初始化列表"><a href="#23-成员初始化列表" class="headerlink" title="23.成员初始化列表"></a>23.成员初始化列表</h1><p>好处：</p>
<ul>
<li><p>更高效：少了一次调用默认构造函数的过程。</p>
</li>
<li><p>有些场合必须要用初始化列表：</p>
</li>
<li><ol>
<li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li>
<li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li>
<li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化</li>
</ol>
</li>
</ul>
<h1 id="24-initializer-list列表初始化"><a href="#24-initializer-list列表初始化" class="headerlink" title="24.initializer_list列表初始化"></a>24.initializer_list列表初始化</h1><p>用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个</p>
<p>std::initializer_list 参数</p>
<p>initalizer_list 使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; v;</span><br><span class="line">    S(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; l) : v(l) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"constructed with a "</span> &lt;&lt; l.<span class="built_in">size</span>() &lt;&lt; <span class="string">"-element list\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; l)</span> </span>&#123;</span><br><span class="line">        v.insert(v.<span class="built_in">end</span>(), l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    std::pair&lt;const T*, std::size_t&gt; c_arr() const &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&amp;v[<span class="number">0</span>], v.<span class="built_in">size</span>()&#125;;  <span class="comment">// 在 return 语句中复制列表初始化</span></span><br><span class="line">                                   <span class="comment">// 这不使用 std::initializer_list</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">templated_fn</span><span class="params">(T)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S&lt;<span class="keyword">int</span>&gt; s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 复制初始化</span></span><br><span class="line">    s.append(&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;);      <span class="comment">// 函数调用中的列表初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The vector size is now "</span> &lt;&lt; s.c_arr().second &lt;&lt; <span class="string">" ints:\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : s.v)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Range-for over brace-init-list: \n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>&#125;) <span class="comment">// auto 的规则令此带范围 for 工作</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> al = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;   <span class="comment">// auto 的特殊规则</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The list bound to auto has size() = "</span> &lt;&lt; al.<span class="built_in">size</span>() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    templated_fn(&#123;1, 2, 3&#125;); // 编译错误！“ &#123;1, 2, 3&#125; ”不是表达式，</span></span><br><span class="line">                             <span class="comment">// 它无类型，故 T 无法推导</span></span><br><span class="line">    templated_fn&lt;<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// OK</span></span><br><span class="line">    templated_fn&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);           <span class="comment">// 也 OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="25-面向对象"><a href="#25-面向对象" class="headerlink" title="25.面向对象"></a>25.面向对象</h1><p>面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。</p>
<p>![面向对象特征](file:///C:/Users/mark/Documents/My Knowledge/temp/22626d50-b89f-4070-a84e-38f4efb8c5a2/128/index_files/0.7574361007068985.png)</p>
<p>面向对象三大特征 —— 封装、继承、多态</p>
<h1 id="26-封装"><a href="#26-封装" class="headerlink" title="26.封装"></a>26.封装</h1><p>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。</p>
<ul>
<li>public 成员：可以被任意实体访问</li>
<li>protected 成员：只允许被子类及本类的成员函数访问</li>
<li>private 成员：只允许被本类的成员函数、友元类或友元函数访问</li>
</ul>
<h1 id="27-继承"><a href="#27-继承" class="headerlink" title="27.继承"></a>27.继承</h1><ul>
<li>基类（父类）–&gt; 派生类（子类）</li>
</ul>
<h1 id="28-多态"><a href="#28-多态" class="headerlink" title="28.多态"></a>28.多态</h1><ul>
<li>多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。</li>
<li>多态是以封装和继承为基础的。</li>
<li>C++ 多态分类及实现：</li>
</ul>
<ol>
<li><ol>
<li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li>
<li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li>
<li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li>
<li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li>
</ol>
</li>
</ol>
<h2 id="静态多态（编译期-早绑定）"><a href="#静态多态（编译期-早绑定）" class="headerlink" title="静态多态（编译期/早绑定）"></a>静态多态（编译期/早绑定）</h2><p>函数重载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void do(int a);</span><br><span class="line">    void do(int a,int b);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="动态多态（运行期期-晚绑定）"><a href="#动态多态（运行期期-晚绑定）" class="headerlink" title="动态多态（运行期期/晚绑定）"></a>动态多态（运行期期/晚绑定）</h2><ul>
<li>虚函数：用 virtual 修饰成员函数，使其成为虚函数</li>
</ul>
<p>注意：</p>
<ul>
<li>普通函数（非类成员函数）不能是虚函数</li>
<li>静态函数（static）不能是虚函数</li>
<li>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）</li>
<li>内联函数不能是表现多态性时的虚函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Shape                                 &#x2F;&#x2F;形状类</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual double calcArea()</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    virtual ~Shape();</span><br><span class="line">&#125;;</span><br><span class="line">class Circle:public Shape                 &#x2F;&#x2F;圆形类</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual double calcArea();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">class Rect : public Shape       &#x2F;&#x2F; 矩形类</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual double calcArea();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Shape * shape1 &#x3D; new Circle(4.0);</span><br><span class="line">    Shape * shape2 &#x3D; new Rect(5.0, 6.0);</span><br><span class="line">    shape1-&gt;calcArea();         &#x2F;&#x2F; 调用圆形类里面的方法</span><br><span class="line">    shape2-&gt;calcArea();         &#x2F;&#x2F; 调用矩形类里面的方法</span><br><span class="line">    delete shape1;</span><br><span class="line">    shape1 &#x3D; nullptr;</span><br><span class="line">    delete shape2;</span><br><span class="line">    shape2 &#x3D; nullptr;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="29-虚析构函数"><a href="#29-虚析构函数" class="headerlink" title="29.虚析构函数"></a>29.虚析构函数</h1><p>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</p>
<p>虚析构函数使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Shape</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Shape();                    &#x2F;&#x2F; 构造函数不能是虚函数</span><br><span class="line">    virtual double calcArea();</span><br><span class="line">    virtual ~Shape();           &#x2F;&#x2F; 虚析构函数</span><br><span class="line">&#125;;</span><br><span class="line">class Circle : public Shape     &#x2F;&#x2F; 圆形类</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual double calcArea();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Shape * shape1 &#x3D; new Circle(4.0);</span><br><span class="line">    shape1-&gt;calcArea();    </span><br><span class="line">    delete shape1;  &#x2F;&#x2F; 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。</span><br><span class="line">    shape1 &#x3D; NULL;</span><br><span class="line">    return 0；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="30-纯虚函数"><a href="#30-纯虚函数" class="headerlink" title="30.纯虚函数"></a>30.纯虚函数</h1><p>纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual int A() &#x3D; 0;</span><br></pre></td></tr></table></figure>

<h1 id="31-虚函数、纯虚函数"><a href="#31-虚函数、纯虚函数" class="headerlink" title="31.虚函数、纯虚函数"></a>31.虚函数、纯虚函数</h1><ul>
<li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。</li>
<li>虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。</li>
<li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。</li>
<li>带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。</li>
<li>虚基类是虚继承中的基类，具体见下文虚继承。</li>
</ul>
<h1 id="32-虚函数指针、虚函数表"><a href="#32-虚函数指针、虚函数表" class="headerlink" title="32.虚函数指针、虚函数表"></a>32.虚函数指针、虚函数表</h1><p>虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。</p>
<p>虚函数表：在程序只读数据段（.rodata section，见：目标文件存储结构），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。</p>
<h1 id="33-虚继承"><a href="#33-虚继承" class="headerlink" title="33.虚继承"></a>33.虚继承</h1><p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。</p>
<p>底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p>
<p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p>
<h1 id="34-虚继承、虚函数"><a href="#34-虚继承、虚函数" class="headerlink" title="34.虚继承、虚函数"></a>34.虚继承、虚函数</h1><ul>
<li><p>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</p>
</li>
<li><p>不同之处：</p>
</li>
<li><ul>
<li><p>虚继承</p>
</li>
<li><ul>
<li>虚基类依旧存在继承类中，只占用存储空间</li>
<li>虚基类表存储的是虚基类相对直接继承类的偏移</li>
</ul>
</li>
<li><p>虚函数</p>
</li>
<li><ul>
<li>虚函数不占用存储空间</li>
<li>虚函数表存储的是虚函数地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="35-抽象类、接口类、聚合类"><a href="#35-抽象类、接口类、聚合类" class="headerlink" title="35.抽象类、接口类、聚合类"></a>35.抽象类、接口类、聚合类</h1><ul>
<li><p>抽象类：含有纯虚函数的类</p>
</li>
<li><p>接口类：仅含有纯虚函数的抽象类</p>
</li>
<li><p>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：</p>
</li>
<li><ul>
<li>所有成员都是 public</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始化</li>
<li>没有基类，也没有 virtual 函数</li>
</ul>
</li>
</ul>
<h1 id="36-内存分配和管理"><a href="#36-内存分配和管理" class="headerlink" title="36.内存分配和管理"></a>36.内存分配和管理</h1><h2 id="malloc、calloc、realloc、alloca"><a href="#malloc、calloc、realloc、alloca" class="headerlink" title="malloc、calloc、realloc、alloca"></a>malloc、calloc、realloc、alloca</h2><ol>
<li>malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。</li>
<li>calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。</li>
<li>realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。</li>
<li>alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。</li>
</ol>
<h2 id="malloc、free"><a href="#malloc、free" class="headerlink" title="malloc、free"></a>malloc、free</h2><p>用于分配、释放内存</p>
<p>申请内存，确定是否申请成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char *str&#x3D;(char*) malloc(100);</span><br><span class="line">assert(str !&#x3D; nullptr);</span><br></pre></td></tr></table></figure>

<p>释放内存后指针置空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">free(p);</span><br><span class="line">p &#x3D; nullptr;</span><br></pre></td></tr></table></figure>

<h2 id="new、delete"><a href="#new、delete" class="headerlink" title="new、delete"></a>new、delete</h2><ol>
<li>new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。</li>
<li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li>
<li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li>
</ol>
<h3 id="new、delete-使用"><a href="#new、delete-使用" class="headerlink" title="new、delete 使用"></a>new、delete 使用</h3><p>申请内存，确认是否申请成功</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T*t = <span class="keyword">new</span> T();</span><br><span class="line">    <span class="keyword">delete</span> t;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定位new"><a href="#定位new" class="headerlink" title="定位new"></a>定位new</h3><p>定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (place_address) type</span><br><span class="line"><span class="keyword">new</span> (place_address) type (initializers)</span><br><span class="line"><span class="keyword">new</span> (place_address) type [<span class="built_in">size</span>]</span><br><span class="line"><span class="keyword">new</span> (place_address) type [<span class="built_in">size</span>] &#123; braced initializer <span class="built_in">list</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>place_address 是个指针</li>
<li>initializers 提供一个（可能为空的）以逗号分隔的初始值列表</li>
</ul>
<h1 id="37-delete-this-合法吗？"><a href="#37-delete-this-合法吗？" class="headerlink" title="37.delete this 合法吗？"></a>37.delete this 合法吗？</h1><p>合法，但：</p>
<ol>
<li>必须保证 this 对象是通过 new（不是 new[]、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li>
<li>必须保证调用 delete this 的成员函数是最后一个调用 this 的成员函数</li>
<li>必须保证成员函数的 delete this 后面没有调用 this 了</li>
<li>必须保证 delete this 后没有人使用了</li>
</ol>
<h1 id="38-如何定义一个只能在堆上（栈上）生成对象的类？"><a href="#38-如何定义一个只能在堆上（栈上）生成对象的类？" class="headerlink" title="38.如何定义一个只能在堆上（栈上）生成对象的类？"></a>38.如何定义一个只能在堆上（栈上）生成对象的类？</h1><h2 id="只能在堆上"><a href="#只能在堆上" class="headerlink" title="只能在堆上"></a>只能在堆上</h2><p>方法：将析构函数设置为私有</p>
<p>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</p>
<h2 id="只能在栈上"><a href="#只能在栈上" class="headerlink" title="只能在栈上"></a>只能在栈上</h2><p>方法：将 new 和 delete 重载为私有</p>
<p>原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</p>
<h1 id="39-智能指针"><a href="#39-智能指针" class="headerlink" title="39.智能指针"></a>39.智能指针</h1><h2 id="C-标准库-STL-中"><a href="#C-标准库-STL-中" class="headerlink" title="C++ 标准库(STL)中"></a>C++ 标准库(STL)中</h2><p>头文件：#include <memory></p>
<h2 id="C-98"><a href="#C-98" class="headerlink" title="C++ 98"></a>C++ 98</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">ps</span> <span class="params">(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(str))</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="C-11"><a href="#C-11" class="headerlink" title="C++ 11"></a>C++ 11</h2><ol>
<li>*<em>shared_ptr<br>*</em></li>
<li>*<em>unique_ptr<br>*</em></li>
<li>*<em>weak_ptr<br>*</em></li>
<li><strong>auto_ptr(被C++11弃用)</strong></li>
</ol>
<ul>
<li>Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。</li>
<li>Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。</li>
</ul>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。</p>
<ul>
<li>支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁</li>
</ul>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。</p>
<ul>
<li>可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题</li>
</ul>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。</p>
<ul>
<li>unique_ptr 用于取代 auto_ptr</li>
</ul>
<h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h3><p>被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 std::move 语义，以及其他瑕疵。</p>
<p>auto_ptr 与 unique_ptr 比较</p>
<ul>
<li>auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了move 语义；</li>
<li>auto_ptr 对象不能管理数组（析构调用 delete），unique_ptr 可以管理数组（析构调用 delete[] ）；</li>
</ul>
<h1 id="40-强制类型转换运算符"><a href="#40-强制类型转换运算符" class="headerlink" title="40.强制类型转换运算符"></a>40.强制类型转换运算符</h1><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><ul>
<li>用于非多态类型的转换</li>
<li>不执行运行时类型检查（转换安全性不如 dynamic_cast）</li>
<li>通常用于转换数值数据类型（如 float -&gt; int）</li>
<li>可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）</li>
</ul>
<p>向上转换是一种隐式转换。</p>
<h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><ul>
<li>用于多态类型的转换</li>
<li>执行行运行时类型检查</li>
<li>只适用于指针或引用</li>
<li>对不明确的指针的转换将失败（返回 nullptr），但不引发异常</li>
<li>可以在整个类层次结构中移动指针，包括向上转换、向下转换</li>
</ul>
<h2 id="Const-cast"><a href="#Const-cast" class="headerlink" title="Const_cast"></a>Const_cast</h2><ul>
<li>用于删除const、volatile和__unaligned特性（如将const int类型转换为int类型）</li>
</ul>
<h2 id="Reinterpret-cast"><a href="#Reinterpret-cast" class="headerlink" title="Reinterpret_cast"></a>Reinterpret_cast</h2><ul>
<li>用于位的简单重新解释</li>
<li>滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。</li>
<li>允许将任何指针转换为任何其他指针类型（如 char* 到 int* 或 One_class* 到 Unrelated_class* 之类的转换，但其本身并不安全）</li>
<li>也允许将任何整数类型转换为任何指针类型以及反向转换。</li>
<li>reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。</li>
<li>reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。</li>
</ul>
<h2 id="bad-cast"><a href="#bad-cast" class="headerlink" title="bad_cast"></a>bad_cast</h2><ul>
<li>由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。</li>
</ul>
<p>bad_cast使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Circle&amp; ref_circle = <span class="keyword">dynamic_cast</span>&lt;Circle&amp;&gt;(ref_shape);</span><br><span class="line">&#125;</span><br><span class="line">each (bad_cast b)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Caught"</span>&lt;&lt;b.what();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="40-运行时类型信息-RTTI"><a href="#40-运行时类型信息-RTTI" class="headerlink" title="40.运行时类型信息(RTTI)"></a>40.运行时类型信息(RTTI)</h1><h2 id="dynamic-cast-1"><a href="#dynamic-cast-1" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><ul>
<li>用于多态类型的转换</li>
</ul>
<h2 id="typeid"><a href="#typeid" class="headerlink" title="typeid"></a>typeid</h2><ul>
<li>typeid 运算符允许在运行时确定对象的类型</li>
<li>type_id 返回一个 type_info 对象的引用</li>
<li>如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数</li>
<li>只能获取对象的实际类型</li>
</ul>
<h2 id="type-info"><a href="#type-info" class="headerlink" title="type_info"></a>type_info</h2><ul>
<li>type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。</li>
<li>头文件：typeinfo</li>
</ul>
<h3 id="typeid、type-info使用"><a href="#typeid、type-info使用" class="headerlink" title="typeid、type_info使用"></a>typeid、type_info使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flyable</span>                       //能飞的</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">takeoff</span><span class="params">()</span></span>=<span class="number">0</span>;       <span class="comment">//起飞</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span></span>=<span class="number">0</span>;          <span class="comment">//降落</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>:</span><span class="keyword">public</span> Flyable           <span class="comment">//鸟</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foraging</span><span class="params">()</span></span>&#123;...&#125;            <span class="comment">//觅食</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">takeoff</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plane</span>:</span><span class="keyword">public</span> Flyable          <span class="comment">//飞机</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">carry</span><span class="params">()</span></span>&#123;...&#125;               <span class="comment">//运输</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> take <span class="title">off</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">type_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>*<span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> type_info &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> type_info &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">before</span><span class="params">(<span class="keyword">const</span> type_info &amp; rhs)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~type_info();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">class <span class="title">doSomething</span><span class="params">(Flyable *obj)</span>                 <span class="comment">// 做些事情</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;takeoff();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(*obj).name() &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 输出传入对象类型（"class Bird" or "class Plane"）</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeid</span>(*obj) == <span class="keyword">typeid</span>(Bird))            <span class="comment">// 判断对象类型</span></span><br><span class="line">    &#123;</span><br><span class="line">        Bird *bird = <span class="keyword">dynamic_cast</span>&lt;Bird *&gt;(obj); <span class="comment">// 对象转化</span></span><br><span class="line">        bird-&gt;foraging();</span><br><span class="line">    &#125;</span><br><span class="line">    obj-&gt;land();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="41-STL详细文档"><a href="#41-STL详细文档" class="headerlink" title="41.STL详细文档"></a>41.STL详细文档</h1><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>array是固定大小的顺序容器，他们保存了一个以严格的线性顺序排列的特定数量的元素。</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>begin</td>
<td>返回指向数组容器中第一个元素的迭代器</td>
</tr>
<tr>
<td>end</td>
<td>返回指向数组容器中最后一个元素之后的理论元素的迭代器</td>
</tr>
<tr>
<td>rbegin</td>
<td>返回指向数组容器中最后一个元素的反向迭代器</td>
</tr>
<tr>
<td>rend</td>
<td>返回一个反向迭代器，指向数组中第一个元素之前的理论元素</td>
</tr>
<tr>
<td>cbegin</td>
<td>返回指向数组容器中第一个元素的常量迭代器（const_iterator）</td>
</tr>
<tr>
<td>cend</td>
<td>返回指向数组容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）</td>
</tr>
<tr>
<td>crbegin</td>
<td>返回指向数组容器中最后一个元素的常量反向迭代器（const_reverse_iterator）</td>
</tr>
<tr>
<td>crend</td>
<td>返回指向数组中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator）</td>
</tr>
<tr>
<td>size</td>
<td>返回数组容器中元素的数量</td>
</tr>
<tr>
<td>max_size</td>
<td>返回数组容器可容纳的最大元素数</td>
</tr>
<tr>
<td>empty</td>
<td>返回一个布尔值，指示数组容器是否为空</td>
</tr>
<tr>
<td>operator[]</td>
<td>返回容器中第 n（参数）个位置的元素的引用</td>
</tr>
<tr>
<td>at</td>
<td>返回容器中第 n（参数）个位置的元素的引用</td>
</tr>
<tr>
<td>front</td>
<td>返回对容器中第一个元素的引用</td>
</tr>
<tr>
<td>back</td>
<td>返回对容器中最后一个元素的引用</td>
</tr>
<tr>
<td>data</td>
<td>返回指向容器中第一个元素的指针</td>
</tr>
<tr>
<td>fill</td>
<td>用 val（参数）填充数组所有元素</td>
</tr>
<tr>
<td>swap</td>
<td>通过 x（参数）的内容交换数组的内容</td>
</tr>
<tr>
<td>get(array)</td>
<td>形如 std::get&lt;0&gt;(myarray)；传入一个数组容器，返回指定位置元素的引用</td>
</tr>
<tr>
<td>relational operators(array)</td>
<td>形如 arrayA &gt; arrayB；依此比较数组每个元素的大小关系</td>
</tr>
</tbody></table>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector 是表示可以改变大小的数组的序列容器。</p>
<p>​                                                                                    </p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>vector</td>
<td>构造函数</td>
</tr>
<tr>
<td>~vector</td>
<td>析构函数，销毁容器对象</td>
</tr>
<tr>
<td>operator=</td>
<td>将新内容分配给容器，替换其当前内容，并相应地修改其大小</td>
</tr>
<tr>
<td>begin</td>
<td>返回指向数组容器中第一个元素的迭代器</td>
</tr>
<tr>
<td>end</td>
<td>返回指向容器中最后一个元素之后的理论元素的迭代器</td>
</tr>
<tr>
<td>rbegin</td>
<td>返回指向容器中最后一个元素的反向迭代器</td>
</tr>
<tr>
<td>rend</td>
<td>返回一个反向迭代器，指向数组中第一个元素之前的理论元素</td>
</tr>
<tr>
<td>cbegin</td>
<td>返回指向容器中第一个元素的常量迭代器（const_iterator）</td>
</tr>
<tr>
<td>cend</td>
<td>返回指向容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）</td>
</tr>
<tr>
<td>crbegin</td>
<td>返回指向容器中最后一个元素的常量反向迭代器（const_reverse_iterator）</td>
</tr>
<tr>
<td>crend</td>
<td>返回指向容器中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator）</td>
</tr>
<tr>
<td>size</td>
<td>返回容器中元素的数量</td>
</tr>
<tr>
<td>max_size</td>
<td>返回容器可容纳的最大元素数</td>
</tr>
<tr>
<td>resize</td>
<td>调整容器的大小，使其包含n(参数)个元素</td>
</tr>
<tr>
<td>capacity</td>
<td>返回当前为vector分配的存储空间(容量)的大小</td>
</tr>
<tr>
<td>empty</td>
<td>返回一个布尔值，指示容器是否为空</td>
</tr>
<tr>
<td>reserve</td>
<td>请求vector容量至少足以包含n(参数)个元素</td>
</tr>
<tr>
<td>shrink_to_fit</td>
<td>要求容器减少其capacity(容量)以适应其size(元素数量)</td>
</tr>
<tr>
<td>operator[]</td>
<td>返回容器中第 n（参数）个位置的元素的引用</td>
</tr>
<tr>
<td>at</td>
<td>返回容器中第 n（参数）个位置的元素的引用</td>
</tr>
<tr>
<td>front</td>
<td>返回对容器中第一个元素的引用</td>
</tr>
<tr>
<td>back</td>
<td>返回对容器中最后一个元素的引用</td>
</tr>
<tr>
<td>data</td>
<td>返回指向容器中第一个元素的指针</td>
</tr>
<tr>
<td>assign</td>
<td>将新内容分配给 vector，替换其当前内容，并相应地修改其 size</td>
</tr>
<tr>
<td>push_back</td>
<td>在容器的最后一个元素之后添加一个新元素</td>
</tr>
<tr>
<td>pop_back</td>
<td>删除容器中的最后一个元素，有效地将容器 size 减少一个</td>
</tr>
<tr>
<td>insert</td>
<td>通过在指定位置的元素之前插入新元素来扩展该容器，通过插入元素的数量有效地增加容器大小</td>
</tr>
<tr>
<td>erase</td>
<td>从 vector 中删除单个元素（position）或一系列元素（[first，last)），这有效地减少了被去除的元素的数量，从而破坏了容器的大小</td>
</tr>
<tr>
<td>swap</td>
<td>通过 x（参数）的内容交换容器的内容，x 是另一个类型相同、size 可能不同的 vector 对象</td>
</tr>
<tr>
<td>clear</td>
<td>从 vector 中删除所有的元素（被销毁），留下 size 为 0 的容器</td>
</tr>
<tr>
<td>emplace</td>
<td>通过在 position（参数）位置处插入新元素 args（参数）来扩展容器</td>
</tr>
<tr>
<td>emplace_back</td>
<td>在 vector 的末尾插入一个新的元素，紧跟在当前的最后一个元素之后</td>
</tr>
<tr>
<td>get_allocator</td>
<td>返回与vector关联的构造器对象的副本</td>
</tr>
<tr>
<td>swap(vector)</td>
<td>容器 x（参数）的内容与容器 y（参数）的内容交换。两个容器对象都必须是相同的类型（相同的模板参数），尽管大小可能不同</td>
</tr>
<tr>
<td>relational operators(array)</td>
<td>形如 vectorA &gt; vectorB；依此比较每个元素的大小关系</td>
</tr>
</tbody></table>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>deque（[‘dek]）（双端队列）是double-ended queue 的一个不规则缩写。deque是具有动态大小的序列容器，可以在两端（前端或后端）扩展或收缩.</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>deque</td>
<td>构造函数</td>
</tr>
<tr>
<td>push_back</td>
<td>在当前的最后一个元素之后，在deque容器的末尾添加一个新元素</td>
</tr>
<tr>
<td>push_front</td>
<td>在deque容器的开始位置插入一个新的元素，位于当前的第一个元素之前</td>
</tr>
<tr>
<td>pop_back</td>
<td>删除 deque 容器中的最后一个元素，有效地将容器大小减少一个</td>
</tr>
<tr>
<td>pop_frint</td>
<td>删除 deque 容器中的第一个元素，有效地减小其大小</td>
</tr>
<tr>
<td>emplace_front</td>
<td>在 deque 的开头插入一个新的元素，就在其当前的第一个元素之前</td>
</tr>
<tr>
<td>emplace_back</td>
<td>在 deque 的末尾插入一个新的元素，紧跟在当前的最后一个元素之后</td>
</tr>
</tbody></table>
<h3 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h3><p>forward_list（单向链表）是序列容器，允许在序列中的任何地方进行恒定的时间插入和擦除操作。</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>forward_list</td>
<td>返回指向容器中第一个元素之前的位置的迭代器</td>
</tr>
<tr>
<td>cbefore_begin</td>
<td>返回指向容器中第一个元素之前的位置的 const_iterator</td>
</tr>
</tbody></table>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list，双向链表，是序列容器，允许在序列中的任何地方进行常数时间插入和擦除操作，并在两个方向上进行迭代。</p>
<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>stack 是一种容器适配器，用于在LIFO（后进先出）的操作，其中元素仅从容器的一端插入和提取。</p>
<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>queue 是一种容器适配器，用于在FIFO（先入先出）的操作，其中元素插入到容器的一端并从另一端提取。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set 是按照特定顺序存储唯一元素的容器。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 是关联容器，按照特定顺序存储由 key value (键值) 和 mapped value (映射值) 组合形成的元素。</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>map</td>
<td>构造函数</td>
</tr>
<tr>
<td>begin</td>
<td>返回引用容器中第一个元素的迭代器</td>
</tr>
<tr>
<td>key_comp</td>
<td>返回容器用于比较键的比较对象的副本</td>
</tr>
<tr>
<td>value_comp</td>
<td>返回可用于比较两个元素的比较对象，以获取第一个元素的键是否在第二个元素之前</td>
</tr>
<tr>
<td>find</td>
<td>在容器中搜索具有等于 k（参数）的键的元素，如果找到则返回一个迭代器，否则返回 map::end 的迭代器</td>
</tr>
<tr>
<td>count</td>
<td>在容器中搜索具有等于 k（参数）的键的元素，并返回匹配的数量</td>
</tr>
<tr>
<td>lower_bound</td>
<td>返回一个非递减序列 [first, last)（参数）中的第一个大于等于值 val（参数）的位置的迭代器</td>
</tr>
<tr>
<td>upper_bound</td>
<td>返回一个非递减序列 [first, last)（参数）中第一个大于 val（参数）的位置的迭代器</td>
</tr>
<tr>
<td>equal_range</td>
<td>获取相同元素的范围，返回包含容器中所有具有与 k（参数）等价的键的元素的范围边界（pair&lt; map&lt;char,int&gt;::iterator, map&lt;char,int&gt;::iterator &gt;）</td>
</tr>
</tbody></table>
<h3 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h3><h3 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h3><h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><h3 id="unordered-multimap"><a href="#unordered-multimap" class="headerlink" title="unordered_multimap"></a>unordered_multimap</h3><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>元组是一个能够容纳元素集合的对象。每个元素可以是不同的类型。</p>
<h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p>这个类把一对值(values)结合在一起，这些值可能是不同的类型(T1和T2)。每个值可任意被共有的成员变量first、second访问。</p>
<h2 id="算法-algorithms"><a href="#算法-algorithms" class="headerlink" title="算法(algorithms)"></a>算法(algorithms)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单查找算法，要求输入迭代器(input iterator)</span></span><br><span class="line"><span class="built_in">find</span>(beg,<span class="built_in">end</span>,val); <span class="comment">//返回一个迭代器，指向输入序列中第一个等于val的元素，未找到返回end</span></span><br><span class="line">find_if(beg,<span class="built_in">end</span>,unaryPred);<span class="comment">//返回一个迭代器，指向输入序列中第一个满足unaryPred的元素，未找到返回end</span></span><br><span class="line">find_if_not(beg, <span class="built_in">end</span>, unaryPred); <span class="comment">// 返回一个迭代器，指向第一个令 unaryPred 为 false 的元素，未找到返回 end</span></span><br><span class="line">count(beg, <span class="built_in">end</span>, val); <span class="comment">// 返回一个计数器，指出 val 出现了多少次</span></span><br><span class="line">count_if(beg, <span class="built_in">end</span>, unaryPred); <span class="comment">// 统计有多少个元素满足 unaryPred</span></span><br><span class="line">all_of(beg, <span class="built_in">end</span>, unaryPred); <span class="comment">// 返回一个 bool 值，判断是否所有元素都满足 unaryPred</span></span><br><span class="line">any_of(beg, <span class="built_in">end</span>, unaryPred); <span class="comment">// 返回一个 bool 值，判断是否任意（存在）一个元素满足 unaryPred</span></span><br><span class="line">none_of(beg, <span class="built_in">end</span>, unaryPred); <span class="comment">// 返回一个 bool 值，判断是否所有元素都不满足 unaryPred</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找重复值的算法，传入向前迭代器（forward iterator）</span></span><br><span class="line">adjacent_find(beg, <span class="built_in">end</span>); <span class="comment">// 返回指向第一对相邻重复元素的迭代器，无相邻元素则返回 end</span></span><br><span class="line">adjacent_find(beg, <span class="built_in">end</span>, binaryPred); <span class="comment">// 返回指向第一对相邻重复元素的迭代器，无相邻元素则返回 end</span></span><br><span class="line">search_n(beg, <span class="built_in">end</span>, count, val); <span class="comment">// 返回一个迭代器，从此位置开始有 count 个相等元素，不存在则返回 end</span></span><br><span class="line">search_n(beg, <span class="built_in">end</span>, count, val, binaryPred); <span class="comment">// 返回一个迭代器，从此位置开始有 count 个相等元素，不存在则返回 end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找子序列算法，除 find_first_of（前两个输入迭代器，后两个前向迭代器） 外，都要求两个前向迭代器</span></span><br><span class="line">search(beg1, end1, beg2, end2); <span class="comment">// 返回第二个输入范围（子序列）在爹一个输入范围中第一次出现的位置，未找到则返回 end1</span></span><br><span class="line">search(beg1, end1, beg2, end2, binaryPred); <span class="comment">// 返回第二个输入范围（子序列）在爹一个输入范围中第一次出现的位置，未找到则返回 end1</span></span><br><span class="line">find_first_of(beg1, end1, beg2, end2); <span class="comment">// 返回一个迭代器，指向第二个输入范围中任意元素在第一个范围中首次出现的位置，未找到则返回end1</span></span><br><span class="line">find_first_of(beg1, end1, beg2, end2, binaryPred); <span class="comment">// 返回一个迭代器，指向第二个输入范围中任意元素在第一个范围中首次出现的位置，未找到则返回end1</span></span><br><span class="line">find_end(beg1, end1, beg2, end2); <span class="comment">// 类似 search，但返回的最后一次出现的位置。如果第二个输入范围为空，或者在第一个输入范围为空，或者在第一个输入范围中未找到它，则返回 end1</span></span><br><span class="line">find_end(beg1, end1, beg2, end2, binaryPred); <span class="comment">// 类似 search，但返回的最后一次出现的位置。如果第二个输入范围为空，或者在第一个输入范围为空，或者在第一个输入范围中未找到它，则返回 end1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他只读算法，传入输入迭代器</span></span><br><span class="line">for_each(beg, <span class="built_in">end</span>, unaryOp); <span class="comment">// 对输入序列中的每个元素应用可调用对象 unaryOp，unaryOp 的返回值被忽略</span></span><br><span class="line">mismatch(beg1, end1, beg2); <span class="comment">// 比较两个序列中的元素。返回一个迭代器的 pair，表示两个序列中第一个不匹配的元素</span></span><br><span class="line">mismatch(beg1, end1, beg2, binaryPred); <span class="comment">// 比较两个序列中的元素。返回一个迭代器的 pair，表示两个序列中第一个不匹配的元素</span></span><br><span class="line">equal(beg1, end1, beg2); <span class="comment">// 比较每个元素，确定两个序列是否相等。</span></span><br><span class="line">equal(beg1, end1, beg2, binaryPred); <span class="comment">// 比较每个元素，确定两个序列是否相等。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分搜索算法，传入前向迭代器或随机访问迭代器（random-access iterator），要求序列中的元素已经是有序的。通过小于运算符（&lt;）或 comp 比较操作实现比较。</span></span><br><span class="line">lower_bound(beg, <span class="built_in">end</span>, val); <span class="comment">// 返回一个非递减序列 [beg, end) 中的第一个大于等于值 val 的位置的迭代器，不存在则返回 end</span></span><br><span class="line">lower_bound(beg, <span class="built_in">end</span>, val, comp); <span class="comment">// 返回一个非递减序列 [beg, end) 中的第一个大于等于值 val 的位置的迭代器，不存在则返回 end</span></span><br><span class="line">upper_bound(beg, <span class="built_in">end</span>, val); <span class="comment">// 返回一个非递减序列 [beg, end) 中第一个大于 val 的位置的迭代器，不存在则返回 end</span></span><br><span class="line">upper_bound(beg, <span class="built_in">end</span>, val, comp); <span class="comment">// 返回一个非递减序列 [beg, end) 中第一个大于 val 的位置的迭代器，不存在则返回 end</span></span><br><span class="line">equal_range(beg, <span class="built_in">end</span>, val); <span class="comment">// 返回一个 pair，其 first 成员是 lower_bound 返回的迭代器，其 second 成员是 upper_bound 返回的迭代器</span></span><br><span class="line">binary_search(beg, <span class="built_in">end</span>, val); <span class="comment">// 返回一个 bool 值，指出序列中是否包含等于 val 的元素。对于两个值 x 和 y，当 x 不小于 y 且 y 也不小于 x 时，认为它们相等。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只写不读算法，要求输出迭代器（output iterator）</span></span><br><span class="line"><span class="built_in">fill</span>(beg, <span class="built_in">end</span>, val); <span class="comment">// 将 val 赋予每个元素，返回 void</span></span><br><span class="line">fill_n(beg, cnt, val); <span class="comment">// 将 val 赋予 cnt 个元素，返回指向写入到输出序列最有一个元素之后位置的迭代器</span></span><br><span class="line">genetate(beg, <span class="built_in">end</span>, Gen); <span class="comment">// 每次调用 Gen() 生成不同的值赋予每个序列，返回 void</span></span><br><span class="line">genetate_n(beg, cnt, Gen); <span class="comment">// 每次调用 Gen() 生成不同的值赋予 cnt 个序列，返回指向写入到输出序列最有一个元素之后位置的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用输入迭代器的写算法，读取一个输入序列，将值写入到一个输出序列（dest）中</span></span><br><span class="line">copy(beg, <span class="built_in">end</span>, dest); <span class="comment">// 从输入范围将元素拷贝所有元素到 dest 指定定的目的序列</span></span><br><span class="line">copy_if(beg, <span class="built_in">end</span>, dest, unaryPred); <span class="comment">// 从输入范围将元素拷贝满足 unaryPred 的元素到 dest 指定定的目的序列</span></span><br><span class="line">copy_n(beg, n, dest); <span class="comment">// 从输入范围将元素拷贝前 n 个元素到 dest 指定定的目的序列</span></span><br><span class="line"><span class="built_in">move</span>(beg, <span class="built_in">end</span>, dest); <span class="comment">// 对输入序列中的每个元素调用 std::move，将其移动到迭代器 dest 开始始的序列中</span></span><br><span class="line">transform(beg, <span class="built_in">end</span>, dest, unaryOp); <span class="comment">// 调用给定操作（一元操作），并将结果写到dest中</span></span><br><span class="line">transform(beg, <span class="built_in">end</span>, beg2, dest, binaryOp); <span class="comment">// 调用给定操作（二元操作），并将结果写到dest中</span></span><br><span class="line">replace_copy(beg, <span class="built_in">end</span>, dest, old_val, new_val); <span class="comment">// 将每个元素拷贝到 dest，将等于 old_val 的的元素替换为 new_val</span></span><br><span class="line">replace_copy_if(beg, <span class="built_in">end</span>, dest, unaryPred, new_val); <span class="comment">// 将每个元素拷贝到 dest，将满足 unaryPred 的的元素替换为 new_val</span></span><br><span class="line">merge(beg1, end1, beg2, end2, dest); <span class="comment">// 两个输入序列必须都是有序的，用 &lt; 运算符将合并后的序列写入到 dest 中</span></span><br><span class="line">merge(beg1, end1, beg2, end2, dest, comp); <span class="comment">// 两个输入序列必须都是有序的，使用给定的比较操作（comp）将合并后的序列写入到 dest 中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用前向迭代器的写算法，要求前向迭代器</span></span><br><span class="line">iter_swap(iter1, iter2); <span class="comment">// 交换 iter1 和 iter2 所表示的元素，返回 void</span></span><br><span class="line">swap_ranges(beg1, end1, beg2); <span class="comment">// 将输入范围中所有元素与 beg2 开始的第二个序列中所有元素进行交换。返回递增后的的 beg2，指向最后一个交换元素之后的位置。</span></span><br><span class="line">replace(beg, <span class="built_in">end</span>, old_val, new_val); <span class="comment">// 用 new_val 替换等于 old_val 的每个匹配元素</span></span><br><span class="line">replace_if(beg, <span class="built_in">end</span>, unaryPred, new_val); <span class="comment">// 用 new_val 替换满足 unaryPred 的每个匹配元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用双向迭代器的写算法，要求双向选代器（bidirectional iterator）</span></span><br><span class="line">copy_backward(beg, <span class="built_in">end</span>, dest); <span class="comment">// 从输入范围中拷贝元素到指定目的位置。如果范围为空,则返回值为 dest；否则，返回值表示从 *beg 中拷贝或移动的元素。</span></span><br><span class="line">move_backward(beg, <span class="built_in">end</span>, dest);  <span class="comment">// 从输入范围中移动元素到指定目的位置。如果范围为空,则返回值为 dest；否则,返回值表示从 *beg 中拷贝或移动的元素。</span></span><br><span class="line">inplace_merge(beg, mid, <span class="built_in">end</span>); <span class="comment">// 将同一个序列中的两个有序子序列合并为单一的有序序列。beg 到 mid 间的子序列和 mid 到 end 间的子序列被合并，并被写入到原序列中。使用 &lt; 比较元素。</span></span><br><span class="line">inplace_merge(beg, mid, <span class="built_in">end</span>, comp); <span class="comment">// 将同一个序列中的两个有序子序列合并为单一的有序序列。beg 到 mid 间的子序列和 mid 到 end 间的子序列被合并，并被写入到原序列中。使用给定的 comp 操作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 划分算法，要求双向选代器（bidirectional iterator）</span></span><br><span class="line">is_partitioned(beg, <span class="built_in">end</span>, unaryPred); <span class="comment">// 如果所有满足谓词 unaryPred 的元素都在不满足 unarypred 的元素之前，则返回 true。若序列为空，也返回 true</span></span><br><span class="line">partition_copy(beg, <span class="built_in">end</span>, dest1, dest2, unaryPred); <span class="comment">// 将满足 unaryPred 的元素拷贝到到 dest1，并将不满足 unaryPred 的元素拷贝到到 dest2。返回一个迭代器 pair，其 first 成员表示拷贝到 dest1 的的元素的末尾，second 表示拷贝到 dest2 的元素的末尾。</span></span><br><span class="line">partitioned_point(beg, <span class="built_in">end</span>, unaryPred); <span class="comment">// 输入序列必须是已经用 unaryPred 划分过的。返回满足  unaryPred 的范围的尾后迭代器。如果返回的迭代器不是 end，则它指向的元素及其后的元素必须都不满足 unaryPred</span></span><br><span class="line">stable_partition(beg, <span class="built_in">end</span>, unaryPred); <span class="comment">// 使用 unaryPred 划分输入序列。满足 unaryPred 的元素放置在序列开始，不满足的元素放在序列尾部。返回一个迭代器，指向最后一个满足 unaryPred 的元素之后的位置如果所有元素都不满足 unaryPred，则返回 beg</span></span><br><span class="line">partition(beg, <span class="built_in">end</span>, unaryPred); <span class="comment">// 使用 unaryPred 划分输入序列。满足 unaryPred 的元素放置在序列开始，不满足的元素放在序列尾部。返回一个迭代器，指向最后一个满足 unaryPred 的元素之后的位置如果所有元素都不满足 unaryPred，则返回 beg</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序算法，要求随机访问迭代器（random-access iterator）</span></span><br><span class="line">sort(beg, <span class="built_in">end</span>); <span class="comment">// 排序整个范围</span></span><br><span class="line">stable_sort(beg, <span class="built_in">end</span>); <span class="comment">// 排序整个范围（稳定排序）</span></span><br><span class="line">sort(beg, <span class="built_in">end</span>, comp); <span class="comment">// 排序整个范围</span></span><br><span class="line">stable_sort(beg, <span class="built_in">end</span>, comp); <span class="comment">// 排序整个范围（稳定排序）</span></span><br><span class="line">is_sorted(beg, <span class="built_in">end</span>); <span class="comment">// 返回一个 bool 值，指出整个输入序列是否有序</span></span><br><span class="line">is_sorted(beg, <span class="built_in">end</span>, comp); <span class="comment">// 返回一个 bool 值，指出整个输入序列是否有序</span></span><br><span class="line">is_sorted_until(beg, <span class="built_in">end</span>); <span class="comment">// 在输入序列中査找最长初始有序子序列，并返回子序列的尾后迭代器</span></span><br><span class="line">is_sorted_until(beg, <span class="built_in">end</span>, comp); <span class="comment">// 在输入序列中査找最长初始有序子序列，并返回子序列的尾后迭代器</span></span><br><span class="line">partial_sort(beg, mid, <span class="built_in">end</span>); <span class="comment">// 排序 mid-beg 个元素。即，如果 mid-beg 等于 42，则此函数将值最小的 42 个元素有序放在序列前 42 个位置</span></span><br><span class="line">partial_sort(beg, mid, <span class="built_in">end</span>, comp); <span class="comment">// 排序 mid-beg 个元素。即，如果 mid-beg 等于 42，则此函数将值最小的 42 个元素有序放在序列前 42 个位置</span></span><br><span class="line">partial_sort_copy(beg, <span class="built_in">end</span>, destBeg, destEnd); <span class="comment">// 排序输入范围中的元素，并将足够多的已排序元素放到 destBeg 和 destEnd 所指示的序列中</span></span><br><span class="line">partial_sort_copy(beg, <span class="built_in">end</span>, destBeg, destEnd, comp); <span class="comment">// 排序输入范围中的元素，并将足够多的已排序元素放到 destBeg 和 destEnd 所指示的序列中</span></span><br><span class="line">nth_element(beg, nth, <span class="built_in">end</span>); <span class="comment">// nth 是一个迭代器，指向输入序列中第 n 大的元素。nth 之前的元素都小于等于它，而之后的元素都大于等于它</span></span><br><span class="line">nth_element(beg, nth, <span class="built_in">end</span>, comp); <span class="comment">// nth 是一个迭代器，指向输入序列中第 n 大的元素。nth 之前的元素都小于等于它，而之后的元素都大于等于它</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用前向迭代器的重排算法。普通版本在输入序列自身内部重拍元素，_copy 版本完成重拍后写入到指定目的序列中，而不改变输入序列</span></span><br><span class="line"><span class="built_in">remove</span>(beg, <span class="built_in">end</span>, val); <span class="comment">// 通过用保留的元素覆盖要删除的元素实现删除 ==val 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器</span></span><br><span class="line">remove_if(beg, <span class="built_in">end</span>, unaryPred); <span class="comment">// 通过用保留的元素覆盖要删除的元素实现删除满足 unaryPred 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器</span></span><br><span class="line">remove_copy(beg, <span class="built_in">end</span>, dest, val); <span class="comment">// 通过用保留的元素覆盖要删除的元素实现删除 ==val 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器</span></span><br><span class="line">remove_copy_if(beg, <span class="built_in">end</span>, dest, unaryPred); <span class="comment">// 通过用保留的元素覆盖要删除的元素实现删除满足 unaryPred 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器</span></span><br><span class="line">unique(beg, <span class="built_in">end</span>); <span class="comment">// 通过对覆盖相邻的重复元素（用 == 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置</span></span><br><span class="line">unique (beg, <span class="built_in">end</span>, binaryPred); <span class="comment">// 通过对覆盖相邻的重复元素（用 binaryPred 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置</span></span><br><span class="line">unique_copy(beg, <span class="built_in">end</span>, dest); <span class="comment">// 通过对覆盖相邻的重复元素（用 == 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置</span></span><br><span class="line">unique_copy_if(beg, <span class="built_in">end</span>, dest, binaryPred); <span class="comment">// 通过对覆盖相邻的重复元素（用 binaryPred 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置</span></span><br><span class="line">rotate(beg, mid, <span class="built_in">end</span>); <span class="comment">// 围绕 mid 指向的元素进行元素转动。元素 mid 成为为首元素，随后是 mid+1 到到 end 之前的元素，再接着是 beg 到 mid 之前的元素。返回一个迭代器，指向原来在 beg 位置的元素</span></span><br><span class="line">rotate_copy(beg, mid, <span class="built_in">end</span>, dest); <span class="comment">// 围绕 mid 指向的元素进行元素转动。元素 mid 成为为首元素，随后是 mid+1 到到 end 之前的元素，再接着是 beg 到 mid 之前的元素。返回一个迭代器，指向原来在 beg 位置的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用双向迭代器的重排算法</span></span><br><span class="line">reverse(beg, <span class="built_in">end</span>); <span class="comment">// 翻转序列中的元素，返回 void</span></span><br><span class="line">reverse_copy(beg, <span class="built_in">end</span>, dest);; <span class="comment">// 翻转序列中的元素，返回一个迭代器，指向拷贝到目的序列的元素的尾后位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用随机访问迭代器的重排算法</span></span><br><span class="line">random_shuffle(beg, <span class="built_in">end</span>); <span class="comment">// 混洗输入序列中的元素，返回 void</span></span><br><span class="line">random_shuffle(beg, <span class="built_in">end</span>, rand); <span class="comment">// 混洗输入序列中的元素，rand 接受一个正整数的随机对象，返回 void</span></span><br><span class="line">shuffle(beg, <span class="built_in">end</span>, Uniform_rand); <span class="comment">// 混洗输入序列中的元素，Uniform_rand 必须满足均匀分布随机数生成器的要求，返回 void</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小值和最大值，使用 &lt; 运算符或给定的比较操作 comp 进行比较</span></span><br><span class="line"><span class="built_in">min</span>(val1, va12); <span class="comment">// 返回 val1 和 val2 中的最小值，两个实参的类型必须完全一致。参数和返回类型都是 const的引引用，意味着对象不会被拷贝。下略</span></span><br><span class="line"><span class="built_in">min</span>(val1, val2, comp);</span><br><span class="line"><span class="built_in">min</span>(init_list);</span><br><span class="line"><span class="built_in">min</span>(init_list, comp);</span><br><span class="line"><span class="built_in">max</span>(val1, val2);</span><br><span class="line"><span class="built_in">max</span>(val1, val2, comp);</span><br><span class="line"><span class="built_in">max</span>(init_list);</span><br><span class="line"><span class="built_in">max</span>(init_list, comp);</span><br><span class="line">minmax(val1, val2); <span class="comment">// 返回一个 pair，其 first 成员为提供的值中的较小者，second 成员为较大者。下略</span></span><br><span class="line">minmax(vall, val2, comp);</span><br><span class="line">minmax(init_list);</span><br><span class="line">minmax(init_list, comp);</span><br><span class="line">min_element(beg, <span class="built_in">end</span>); <span class="comment">// 返回指向输入序列中最小元素的迭代器</span></span><br><span class="line">min_element(beg, <span class="built_in">end</span>, comp); <span class="comment">// 返回指向输入序列中最小元素的迭代器</span></span><br><span class="line">max_element(beg, <span class="built_in">end</span>); <span class="comment">// 返回指向输入序列中最大元素的迭代器</span></span><br><span class="line">max_element(beg, <span class="built_in">end</span>, comp); <span class="comment">// 返回指向输入序列中最大元素的迭代器</span></span><br><span class="line">minmax_element(beg, <span class="built_in">end</span>); <span class="comment">// 返回一个 pair，其中 first 成员为最小元素，second 成员为最大元素</span></span><br><span class="line">minmax_element(beg, <span class="built_in">end</span>, comp); <span class="comment">// 返回一个 pair，其中 first 成员为最小元素，second 成员为最大元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典序比较，根据第一对不相等的元素的相对大小来返回结果。如果第一个序列在字典序中小于第二个序列，则返回 true。否则，返回 fa1se。如果个序列比另一个短，且所有元素都与较长序列的对应元素相等，则较短序列在字典序中更小。如果序列长度相等，且对应元素都相等，则在字典序中任何一个都不大于另外一个。</span></span><br><span class="line">lexicographical_compare(beg1, end1, beg2, end2);</span><br><span class="line">lexicographical_compare(beg1, end1, beg2, end2, comp);</span><br></pre></td></tr></table></figure>

<h1 id="42-数据结构"><a href="#42-数据结构" class="headerlink" title="42.数据结构"></a>42.数据结构</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="单链表-双向链表循环链表"><a href="#单链表-双向链表循环链表" class="headerlink" title="单链表   双向链表循环链表"></a>单链表   双向链表循环链表</h3><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h2 id="堆和优先队列"><a href="#堆和优先队列" class="headerlink" title="堆和优先队列"></a>堆和优先队列</h2><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2020/05/11/interview1/" rel="next" title="interview1">
      interview1 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#16-friend友元类和友元函数"><span class="nav-number">1.</span> <span class="nav-text">16.friend友元类和友元函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17-using"><span class="nav-number">2.</span> <span class="nav-text">17.using</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#using声明"><span class="nav-number">2.1.</span> <span class="nav-text">using声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造函数的using声明"><span class="nav-number">2.2.</span> <span class="nav-text">构造函数的using声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#using指示"><span class="nav-number">2.3.</span> <span class="nav-text">using指示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#尽量少使用-using-指示-污染命名空间"><span class="nav-number">2.4.</span> <span class="nav-text">尽量少使用 using 指示 污染命名空间</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-范围解析运算符"><span class="nav-number">3.</span> <span class="nav-text">18.::范围解析运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分类"><span class="nav-number">3.1.</span> <span class="nav-text">分类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-enum枚举类型"><span class="nav-number">4.</span> <span class="nav-text">19.enum枚举类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#限定作用域的枚举类型"><span class="nav-number">4.1.</span> <span class="nav-text">限定作用域的枚举类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不限定作用域的枚举类型"><span class="nav-number">4.2.</span> <span class="nav-text">不限定作用域的枚举类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20-decltype"><span class="nav-number">5.</span> <span class="nav-text">20.decltype</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21-引用"><span class="nav-number">6.</span> <span class="nav-text">21.引用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#左值引用"><span class="nav-number">6.1.</span> <span class="nav-text">左值引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#右值引用"><span class="nav-number">6.2.</span> <span class="nav-text">右值引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引用折叠"><span class="nav-number">6.3.</span> <span class="nav-text">引用折叠</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22-宏"><span class="nav-number">7.</span> <span class="nav-text">22.宏</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23-成员初始化列表"><span class="nav-number">8.</span> <span class="nav-text">23.成员初始化列表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24-initializer-list列表初始化"><span class="nav-number">9.</span> <span class="nav-text">24.initializer_list列表初始化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#25-面向对象"><span class="nav-number">10.</span> <span class="nav-text">25.面向对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-封装"><span class="nav-number">11.</span> <span class="nav-text">26.封装</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#27-继承"><span class="nav-number">12.</span> <span class="nav-text">27.继承</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#28-多态"><span class="nav-number">13.</span> <span class="nav-text">28.多态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#静态多态（编译期-早绑定）"><span class="nav-number">13.1.</span> <span class="nav-text">静态多态（编译期&#x2F;早绑定）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态多态（运行期期-晚绑定）"><span class="nav-number">13.2.</span> <span class="nav-text">动态多态（运行期期&#x2F;晚绑定）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#29-虚析构函数"><span class="nav-number">14.</span> <span class="nav-text">29.虚析构函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#30-纯虚函数"><span class="nav-number">15.</span> <span class="nav-text">30.纯虚函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#31-虚函数、纯虚函数"><span class="nav-number">16.</span> <span class="nav-text">31.虚函数、纯虚函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#32-虚函数指针、虚函数表"><span class="nav-number">17.</span> <span class="nav-text">32.虚函数指针、虚函数表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#33-虚继承"><span class="nav-number">18.</span> <span class="nav-text">33.虚继承</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#34-虚继承、虚函数"><span class="nav-number">19.</span> <span class="nav-text">34.虚继承、虚函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#35-抽象类、接口类、聚合类"><span class="nav-number">20.</span> <span class="nav-text">35.抽象类、接口类、聚合类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#36-内存分配和管理"><span class="nav-number">21.</span> <span class="nav-text">36.内存分配和管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc、calloc、realloc、alloca"><span class="nav-number">21.1.</span> <span class="nav-text">malloc、calloc、realloc、alloca</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc、free"><span class="nav-number">21.2.</span> <span class="nav-text">malloc、free</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new、delete"><span class="nav-number">21.3.</span> <span class="nav-text">new、delete</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#new、delete-使用"><span class="nav-number">21.3.1.</span> <span class="nav-text">new、delete 使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定位new"><span class="nav-number">21.3.2.</span> <span class="nav-text">定位new</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#37-delete-this-合法吗？"><span class="nav-number">22.</span> <span class="nav-text">37.delete this 合法吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#38-如何定义一个只能在堆上（栈上）生成对象的类？"><span class="nav-number">23.</span> <span class="nav-text">38.如何定义一个只能在堆上（栈上）生成对象的类？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#只能在堆上"><span class="nav-number">23.1.</span> <span class="nav-text">只能在堆上</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#只能在栈上"><span class="nav-number">23.2.</span> <span class="nav-text">只能在栈上</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#39-智能指针"><span class="nav-number">24.</span> <span class="nav-text">39.智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-标准库-STL-中"><span class="nav-number">24.1.</span> <span class="nav-text">C++ 标准库(STL)中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-98"><span class="nav-number">24.2.</span> <span class="nav-text">C++ 98</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11"><span class="nav-number">24.3.</span> <span class="nav-text">C++ 11</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#shared-ptr"><span class="nav-number">24.3.1.</span> <span class="nav-text">shared_ptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#weak-ptr"><span class="nav-number">24.3.2.</span> <span class="nav-text">weak_ptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unique-ptr"><span class="nav-number">24.3.3.</span> <span class="nav-text">unique_ptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#auto-ptr"><span class="nav-number">24.3.4.</span> <span class="nav-text">auto_ptr</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#40-强制类型转换运算符"><span class="nav-number">25.</span> <span class="nav-text">40.强制类型转换运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#static-cast"><span class="nav-number">25.1.</span> <span class="nav-text">static_cast</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dynamic-cast"><span class="nav-number">25.2.</span> <span class="nav-text">dynamic_cast</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Const-cast"><span class="nav-number">25.3.</span> <span class="nav-text">Const_cast</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reinterpret-cast"><span class="nav-number">25.4.</span> <span class="nav-text">Reinterpret_cast</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bad-cast"><span class="nav-number">25.5.</span> <span class="nav-text">bad_cast</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#40-运行时类型信息-RTTI"><span class="nav-number">26.</span> <span class="nav-text">40.运行时类型信息(RTTI)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#dynamic-cast-1"><span class="nav-number">26.1.</span> <span class="nav-text">dynamic_cast</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typeid"><span class="nav-number">26.2.</span> <span class="nav-text">typeid</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#type-info"><span class="nav-number">26.3.</span> <span class="nav-text">type_info</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#typeid、type-info使用"><span class="nav-number">26.3.1.</span> <span class="nav-text">typeid、type_info使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#41-STL详细文档"><span class="nav-number">27.</span> <span class="nav-text">41.STL详细文档</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#容器"><span class="nav-number">27.1.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#array"><span class="nav-number">27.1.1.</span> <span class="nav-text">array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vector"><span class="nav-number">27.1.2.</span> <span class="nav-text">vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deque"><span class="nav-number">27.1.3.</span> <span class="nav-text">deque</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#forward-list"><span class="nav-number">27.1.4.</span> <span class="nav-text">forward_list</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list"><span class="nav-number">27.1.5.</span> <span class="nav-text">list</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stack"><span class="nav-number">27.1.6.</span> <span class="nav-text">stack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#queue"><span class="nav-number">27.1.7.</span> <span class="nav-text">queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set"><span class="nav-number">27.1.8.</span> <span class="nav-text">set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map"><span class="nav-number">27.1.9.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#multimap"><span class="nav-number">27.1.10.</span> <span class="nav-text">multimap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unordered-set"><span class="nav-number">27.1.11.</span> <span class="nav-text">unordered_set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unordered-map"><span class="nav-number">27.1.12.</span> <span class="nav-text">unordered_map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unordered-multimap"><span class="nav-number">27.1.13.</span> <span class="nav-text">unordered_multimap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tuple"><span class="nav-number">27.1.14.</span> <span class="nav-text">tuple</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pair"><span class="nav-number">27.1.15.</span> <span class="nav-text">pair</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法-algorithms"><span class="nav-number">27.2.</span> <span class="nav-text">算法(algorithms)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#42-数据结构"><span class="nav-number">28.</span> <span class="nav-text">42.数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#链表"><span class="nav-number">28.1.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单链表-双向链表循环链表"><span class="nav-number">28.1.1.</span> <span class="nav-text">单链表   双向链表循环链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#栈和队列"><span class="nav-number">28.2.</span> <span class="nav-text">栈和队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合"><span class="nav-number">28.3.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希表"><span class="nav-number">28.4.</span> <span class="nav-text">哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树"><span class="nav-number">28.5.</span> <span class="nav-text">树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆和优先队列"><span class="nav-number">28.6.</span> <span class="nav-text">堆和优先队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图"><span class="nav-number">28.7.</span> <span class="nav-text">图</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mark"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Mark</p>
  <div class="site-description" itemprop="description">cv小学生，不擅长c++，python，机器学习，深度学习</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mark</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
