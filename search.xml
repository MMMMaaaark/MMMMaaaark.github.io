<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>推荐一款手游</title>
    <url>/2020/05/12/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BE%E6%89%8B%E6%B8%B8/</url>
    <content><![CDATA[<p>最近痴迷一款单机手游,欲罢不能。名字叫做汉末霸业<del>~</del></p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
  </entry>
  <entry>
    <title>interview</title>
    <url>/2020/05/12/interview/</url>
    <content><![CDATA[<h1 id="1-const"><a href="#1-const" class="headerlink" title="1.const"></a>1.const</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li>修饰变量，<strong>说明该变量不可以被改变</strong>；</li>
<li>修饰指针，分为<strong>指向常量的指针和指针常量</strong>；</li>
<li>常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li>
<li>修饰<strong>成员函数</strong>，说明该成员函数内<strong>不能修改成员变量</strong>。</li>
</ol>
<a id="more"></a>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>const使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;                <span class="comment">// 常对象成员，只能在初始化列表赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    A() : a(<span class="number">0</span>) &#123; &#125;;</span><br><span class="line">    A(<span class="keyword">int</span> x) : a(x) &#123; &#125;;        <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;             <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span>;       <span class="comment">// 常成员函数，不得修改类中的任何数据成员的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    A b;                        <span class="comment">// 普通对象，可以调用全部成员函数、更新常成员变量</span></span><br><span class="line">    <span class="keyword">const</span> A a;                  <span class="comment">// 常对象，只能调用常成员函数</span></span><br><span class="line">    <span class="keyword">const</span> A *p = &amp;a;            <span class="comment">// 常指针</span></span><br><span class="line">    <span class="keyword">const</span> A &amp;q = a;             <span class="comment">// 常引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针</span></span><br><span class="line">    <span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">char</span>* p1 = greeting;                <span class="comment">// 指针变量，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p2 = greeting;          <span class="comment">// 指针变量，指向字符数组常量</span></span><br><span class="line">    <span class="keyword">char</span>* <span class="keyword">const</span> p3 = greeting;          <span class="comment">// 常指针，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p4 = greeting;    <span class="comment">// 常指针，指向字符数组常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> Var)</span></span>;           <span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* Var)</span></span>;         <span class="comment">// 参数指针所指内容为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function3</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span> Var)</span></span>;         <span class="comment">// 参数指针为常指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function4</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">function5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="title">function6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="keyword">const</span> <span class="title">function7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span></span><br></pre></td></tr></table></figure>

<h1 id="2-static"><a href="#2-static" class="headerlink" title="2.static"></a>2.static</h1><h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><ol>
<li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在<strong>静态区</strong>，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li>
<li>修饰普通函数，表明函数的作用范围，<strong>仅在定义该函数的文件内</strong>才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li>
<li>修饰成员变量，<strong>修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象</strong>就可以访问该成员。</li>
<li>修饰成员函数，修饰成员函数使得<strong>不需要生成对象就可以访问该函数</strong>，但是在 static 函数内不能访问非静态成员。</li>
</ol>
<h1 id="3-this指针"><a href="#3-this指针" class="headerlink" title="3.this指针"></a>3.this指针</h1><ol>
<li><p><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。</p>
</li>
<li><p>当对一个对象调用成员函数时，编译程序<strong>先将对象的地址</strong>赋给 <code>this</code> 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针。</p>
</li>
<li><p>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</p>
</li>
<li><p><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是<strong>不可修改的</strong>（即不能对这种对象的数据成员进行赋值操作）；</p>
</li>
<li><p><code>this</code> 并不是一个常规变量，<strong>而是个右值</strong>，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</p>
</li>
<li><p>在以下场景中，经常需要显式引用 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span></span><br></pre></td></tr></table></figure>

<p> 指针：</p>
<ol>
<li>为实现对象的链式引用；</li>
<li>为避免对同一对象进行赋值操作；</li>
<li>在实现一些数据结构时，如 <code>list</code>。</li>
</ol>
</li>
</ol>
<h1 id="4-inline内联函数"><a href="#4-inline内联函数" class="headerlink" title="4.inline内联函数"></a>4.inline内联函数</h1><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul>
<li>相当于把内联函数里面的内容写在调用内联函数处；</li>
<li>相当于<strong>不用执行进入函数的步骤，直接执行函数体</strong>；</li>
<li><strong>相当于宏</strong>，却比宏多了类型检查，真正具有函数特性；</li>
<li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li>
<li>在类声明中定义的函数，除了虚函数的其他函数都会<strong>自动隐式地当成内联函数</strong>。</li>
</ul>
<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明1（加inline，建议使用）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> second,...)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 声明2（不加inline）</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> second,...)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 定义</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> second,...)</span></span>&#123;<span class="comment">/****/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内定义，隐式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;         <span class="comment">// 隐式内联</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义，需要显式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">A::doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;   <span class="comment">// 需要显式内联</span></span><br></pre></td></tr></table></figure>

<h2 id="虚函数（virtual）可以是内联函数（inline）吗"><a href="#虚函数（virtual）可以是内联函数（inline）吗" class="headerlink" title="虚函数（virtual）可以是内联函数（inline）吗"></a>虚函数（virtual）可以是内联函数（inline）吗</h2><p>虚函数内联使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Base\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Base() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span>  <span class="comment">// 不写inline时隐式内联</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Derived\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 </span></span><br><span class="line">    Base b;</span><br><span class="line">    b.who();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  </span></span><br><span class="line">    Base *ptr = <span class="keyword">new</span> Derived();</span><br><span class="line">    ptr-&gt;who();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-volatile"><a href="#5-volatile" class="headerlink" title="5.volatile"></a>5.volatile</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</li>
<li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li>
<li>const 可以是 volatile （如只读的状态寄存器）</li>
<li>指针可以是 volatile</li>
</ul>
<h1 id="6-assert"><a href="#6-assert" class="headerlink" title="6.assert()"></a>6.assert()</h1><p>断言，是宏，而非函数。assert 宏的原型定义在 <code>（C）、</code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 assert，但是需要在源代码的开头，<code>include</code> 之前。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG          <span class="comment">// 加上这行，则 assert 不可用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">assert( p != <span class="literal">NULL</span> );    <span class="comment">// assert 不可用</span></span><br></pre></td></tr></table></figure>

<h1 id="7-sizeof"><a href="#7-sizeof" class="headerlink" title="7.sizeof()"></a>7.sizeof()</h1><ul>
<li>sizeof 对数组，得到整个数组所占空间大小。</li>
<li>sizeof 对指针，得到指针本身所占空间大小。</li>
</ul>
<h1 id="8-pragma-pack-n"><a href="#8-pragma-pack-n" class="headerlink" title="8.#pragma pack(n)"></a>8.#pragma pack(n)</h1><p>设定结构体、联合以及类成员变量以 n 字节方式对齐</p>
<p>#pragma pack(n) 使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push)  <span class="comment">// 保存对齐状态</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)     <span class="comment">// 设定为 4 字节对齐</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> m1;</span><br><span class="line">    <span class="keyword">double</span> m4;</span><br><span class="line">    <span class="keyword">int</span> m3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)   <span class="comment">// 恢复对齐状态</span></span></span><br></pre></td></tr></table></figure>

<h1 id="9-位域"><a href="#9-位域" class="headerlink" title="9.位域"></a>9.位域</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Bit mode:<span class="number">2</span>; <span class="comment">// mode 占 2 位</span></span><br></pre></td></tr></table></figure>

<p>类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</p>
<ul>
<li>位域在内存中的布局是与机器有关的</li>
<li>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定</li>
<li>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</li>
</ul>
<p><strong>10.extern”C”</strong></p>
<ul>
<li>被 extern 限定的函数或变量是 extern 类型的</li>
<li>被 <code>extern &quot;C&quot;</code> 修饰的变量和函数是按照 C 语言方式编译和链接的</li>
</ul>
<p><code>extern &quot;C&quot;</code> 的作用是让 C++ 编译器将 <code>extern &quot;C&quot;</code> 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</p>
<p>extern “C” 使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">int</span>, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h1 id="11-struct和typedef-struct"><a href="#11-struct和typedef-struct" class="headerlink" title="11.struct和typedef struct"></a>11.struct和typedef struct</h1><h2 id="c中"><a href="#c中" class="headerlink" title="c中"></a>c中</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; S;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">S</span>;</span></span><br></pre></td></tr></table></figure>

<p>此时 S 等价于 struct Student，但两个标识符名称空间不相同。</p>
<p>另外还可以定义与 struct Student 不冲突的 void Student() {}。</p>
<h2 id="C-中"><a href="#C-中" class="headerlink" title="C++中"></a>C++中</h2><p>由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。</p>
<p>一、如果在类标识符空间定义了 struct Student {…};，使用 Student me; 时，编译器将搜索全局标识符表，Student 未找到，则在类标识符内搜索。</p>
<p>即表现为可以使用 Student 也可以使用 struct Student，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( Student me )</span></span>;       <span class="comment">// 正确，"struct" 关键字可省略</span></span><br></pre></td></tr></table></figure>

<p>二、若定义了与 Student 同名函数之后，则 Student 只代表函数，不代表结构体，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;&#125;           <span class="comment">// 正确，定义后 "Student" 只代表此函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void S() &#123;&#125;               // 错误，符号 "S" 已经被定义为一个 "struct Student" 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student(); </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">me</span>;</span>      <span class="comment">// 或者 "S me";</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="12-C-中struct和class"><a href="#12-C-中struct和class" class="headerlink" title="12.C++中struct和class"></a>12.C++中struct和class</h1><p>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>最本质的一个区别就是默认的访问控制</li>
</ul>
<ol>
<li>默认的继承访问权限。struct 是 public 的，class 是 private 的。</li>
<li>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</li>
</ol>
<h1 id="13-union-联合"><a href="#13-union-联合" class="headerlink" title="13.union 联合"></a>13.union 联合</h1><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p>
<ul>
<li>默认访问控制符为 public</li>
<li>可以含有构造函数、析构函数</li>
<li>不能含有引用类型的成员</li>
<li>不能继承自其他类，不能作为基类</li>
<li>不能含有虚函数</li>
<li>匿名 union 在定义所在作用域可直接访问 union 成员</li>
<li>匿名 union 不能包含 protected 成员或 private 成员</li>
<li>全局匿名联合必须是静态（static）的</li>
</ul>
<h2 id="union使用"><a href="#union使用" class="headerlink" title="union使用"></a>union使用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> UnionTest &#123;</span><br><span class="line">    UnionTest() : i(<span class="number">10</span>) &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UnionTest u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; u.i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出 UnionTest 联合的 10</span></span><br><span class="line"></span><br><span class="line">    ::i = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出全局静态匿名联合的 20</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// 输出局部匿名联合的 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="14-C实现C-类"><a href="#14-C实现C-类" class="headerlink" title="14.C实现C++类"></a>14.C实现C++类</h1><p>C实现C++的面向对象特性（封装、继承、多态）</p>
<ul>
<li>封装：使用函数指针把属性与方法封装到结构体中</li>
<li>继承：结构体嵌套</li>
<li>多态：父类与子类方法的函数指针不同</li>
</ul>
<h1 id="15-explicit-显式-关键字"><a href="#15-explicit-显式-关键字" class="headerlink" title="15.explicit (显式) 关键字"></a>15.explicit (显式) 关键字</h1><ul>
<li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li>
<li>explicit 修饰转换函数时，可以防止隐式转换，但按语境转换除外</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    A(<span class="keyword">int</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doA</span><span class="params">(A a)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doB</span><span class="params">(B b)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    A a2 = <span class="number">1</span>;</span><br><span class="line">    A a3&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    A a4 = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    A a5 = (A)<span class="number">1</span>;</span><br><span class="line">    doA(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a1);</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">a6</span> <span class="params">(a1)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> a7 = a1;</span><br><span class="line">    <span class="keyword">bool</span> a8 = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(a1);</span><br><span class="line">    </span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    B b2 = <span class="number">1</span>;</span><br><span class="line">    B b3&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    B b4=&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    B b5=(B)<span class="number">1</span>;</span><br><span class="line">    doB(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (b1):</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">b6</span><span class="params">(b1)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> b7=b1;</span><br><span class="line">    <span class="keyword">bool</span> b8=<span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(b1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="16-friend友元类和友元函数"><a href="#16-friend友元类和友元函数" class="headerlink" title="16.friend友元类和友元函数"></a>16.friend友元类和友元函数</h1><ul>
<li>能访问私有成员</li>
<li>破坏封装性</li>
<li>友元关系不可传递</li>
<li>友元关系的单向性</li>
<li>友元声明的形式及数量不受限制</li>
</ul>
<!--more-->

<h1 id="17-using"><a href="#17-using" class="headerlink" title="17.using"></a>17.using</h1><h2 id="using声明"><a href="#using声明" class="headerlink" title="using声明"></a>using声明</h2><p>一条 using 声明 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> namespace_name::name;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数的using声明"><a href="#构造函数的using声明" class="headerlink" title="构造函数的using声明"></a>构造函数的using声明</h2><p>在 C++11 中，派生类能够重用其直接基类定义的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Derived(parms) : Base(args) &#123; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="using指示"><a href="#using指示" class="headerlink" title="using指示"></a>using指示</h2><p>using 指示 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> namespace_name name;</span><br></pre></td></tr></table></figure>

<h2 id="尽量少使用-using-指示-污染命名空间"><a href="#尽量少使用-using-指示-污染命名空间" class="headerlink" title="尽量少使用 using 指示 污染命名空间"></a>尽量少使用 using 指示 污染命名空间</h2><p>一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它只导入了指定的名称。如果该名称与局部名称发生冲突，编译器将发出指示。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p>
<p>using使用</p>
<p>尽量少使用 using 指示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>

<p>应该多使用 using 声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x ;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<h1 id="18-范围解析运算符"><a href="#18-范围解析运算符" class="headerlink" title="18.::范围解析运算符"></a>18.::范围解析运算符</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol>
<li>全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li>
<li>类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的</li>
<li>命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的</li>
</ol>
<p>:: 使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;        <span class="comment">// 全局（::）的 count</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count; <span class="comment">// 类 A 的 count（A::count）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ::count = <span class="number">1</span>;      <span class="comment">// 设置全局的 count 的值为 1</span></span><br><span class="line"></span><br><span class="line">    A::count = <span class="number">2</span>;     <span class="comment">// 设置类 A 的 count 为 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;    <span class="comment">// 局部的 count</span></span><br><span class="line">    count = <span class="number">3</span>;        <span class="comment">// 设置局部的 count 的值为 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="19-enum枚举类型"><a href="#19-enum枚举类型" class="headerlink" title="19.enum枚举类型"></a>19.enum枚举类型</h1><h2 id="限定作用域的枚举类型"><a href="#限定作用域的枚举类型" class="headerlink" title="限定作用域的枚举类型"></a>限定作用域的枚举类型</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">open_modes</span> &#123;</span>input,output,append&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="不限定作用域的枚举类型"><a href="#不限定作用域的枚举类型" class="headerlink" title="不限定作用域的枚举类型"></a>不限定作用域的枚举类型</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> color &#123;red,yellow,green&#125;;</span><br><span class="line"><span class="keyword">enum</span> &#123;floatPrec=<span class="number">6</span>,doublePrec=<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="20-decltype"><a href="#20-decltype" class="headerlink" title="20.decltype"></a>20.decltype</h1><p>decltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span> ( expression )</span><br></pre></td></tr></table></figure>

<p>decltype 使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尾置返回允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn(It beg, It end) -&gt; decltype(*beg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;    <span class="comment">// 返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为了使用模板参数成员，必须用 typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;    <span class="comment">// 返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="21-引用"><a href="#21-引用" class="headerlink" title="21.引用"></a>21.引用</h1><h2 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h2><p>常规引用，一般表示对象的身份。</p>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。</p>
<p>右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：</p>
<ul>
<li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li>
<li>能够更简洁明确地定义泛型函数。</li>
</ul>
<h2 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h2><ul>
<li>X&amp; &amp;、X&amp; &amp;&amp;、X&amp;&amp; &amp; 可折叠成 X&amp;</li>
<li>X&amp;&amp; &amp;&amp; 可折叠成 X&amp;&amp;</li>
</ul>
<h1 id="22-宏"><a href="#22-宏" class="headerlink" title="22.宏"></a>22.宏</h1><ul>
<li>宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。</li>
</ul>
<h1 id="23-成员初始化列表"><a href="#23-成员初始化列表" class="headerlink" title="23.成员初始化列表"></a>23.成员初始化列表</h1><p>好处：</p>
<ul>
<li><p>更高效：少了一次调用默认构造函数的过程。</p>
</li>
<li><p>有些场合必须要用初始化列表：</p>
</li>
<li><ol>
<li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li>
<li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li>
<li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化</li>
</ol>
</li>
</ul>
<h1 id="24-initializer-list列表初始化"><a href="#24-initializer-list列表初始化" class="headerlink" title="24.initializer_list列表初始化"></a>24.initializer_list列表初始化</h1><p>用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个</p>
<p>std::initializer_list 参数</p>
<p>initalizer_list 使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; v;</span><br><span class="line">    S(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; l) : v(l) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"constructed with a "</span> &lt;&lt; l.<span class="built_in">size</span>() &lt;&lt; <span class="string">"-element list\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; l)</span> </span>&#123;</span><br><span class="line">        v.insert(v.<span class="built_in">end</span>(), l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    std::pair&lt;const T*, std::size_t&gt; c_arr() const &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&amp;v[<span class="number">0</span>], v.<span class="built_in">size</span>()&#125;;  <span class="comment">// 在 return 语句中复制列表初始化</span></span><br><span class="line">                                   <span class="comment">// 这不使用 std::initializer_list</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">templated_fn</span><span class="params">(T)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S&lt;<span class="keyword">int</span>&gt; s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 复制初始化</span></span><br><span class="line">    s.append(&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;);      <span class="comment">// 函数调用中的列表初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The vector size is now "</span> &lt;&lt; s.c_arr().second &lt;&lt; <span class="string">" ints:\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : s.v)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Range-for over brace-init-list: \n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>&#125;) <span class="comment">// auto 的规则令此带范围 for 工作</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> al = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;   <span class="comment">// auto 的特殊规则</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The list bound to auto has size() = "</span> &lt;&lt; al.<span class="built_in">size</span>() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    templated_fn(&#123;1, 2, 3&#125;); // 编译错误！“ &#123;1, 2, 3&#125; ”不是表达式，</span></span><br><span class="line">                             <span class="comment">// 它无类型，故 T 无法推导</span></span><br><span class="line">    templated_fn&lt;<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// OK</span></span><br><span class="line">    templated_fn&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);           <span class="comment">// 也 OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="25-面向对象"><a href="#25-面向对象" class="headerlink" title="25.面向对象"></a>25.面向对象</h1><p>面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。</p>
<p>![面向对象特征](file:///C:/Users/mark/Documents/My Knowledge/temp/22626d50-b89f-4070-a84e-38f4efb8c5a2/128/index_files/0.7574361007068985.png)</p>
<p>面向对象三大特征 —— 封装、继承、多态</p>
<h1 id="26-封装"><a href="#26-封装" class="headerlink" title="26.封装"></a>26.封装</h1><p>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。</p>
<ul>
<li>public 成员：可以被任意实体访问</li>
<li>protected 成员：只允许被子类及本类的成员函数访问</li>
<li>private 成员：只允许被本类的成员函数、友元类或友元函数访问</li>
</ul>
<h1 id="27-继承"><a href="#27-继承" class="headerlink" title="27.继承"></a>27.继承</h1><ul>
<li>基类（父类）–&gt; 派生类（子类）</li>
</ul>
<h1 id="28-多态"><a href="#28-多态" class="headerlink" title="28.多态"></a>28.多态</h1><ul>
<li>多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。</li>
<li>多态是以封装和继承为基础的。</li>
<li>C++ 多态分类及实现：</li>
</ul>
<ol>
<li><ol>
<li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li>
<li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li>
<li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li>
<li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li>
</ol>
</li>
</ol>
<h2 id="静态多态（编译期-早绑定）"><a href="#静态多态（编译期-早绑定）" class="headerlink" title="静态多态（编译期/早绑定）"></a>静态多态（编译期/早绑定）</h2><p>函数重载</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="动态多态（运行期期-晚绑定）"><a href="#动态多态（运行期期-晚绑定）" class="headerlink" title="动态多态（运行期期/晚绑定）"></a>动态多态（运行期期/晚绑定）</h2><ul>
<li>虚函数：用 virtual 修饰成员函数，使其成为虚函数</li>
</ul>
<p>注意：</p>
<ul>
<li>普通函数（非类成员函数）不能是虚函数</li>
<li>静态函数（static）不能是虚函数</li>
<li>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）</li>
<li>内联函数不能是表现多态性时的虚函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>                                 //形状类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Shape();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span><span class="keyword">public</span> Shape                 <span class="comment">//圆形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> :</span> <span class="keyword">public</span> Shape       <span class="comment">// 矩形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape * shape1 = <span class="keyword">new</span> Circle(<span class="number">4.0</span>);</span><br><span class="line">    Shape * shape2 = <span class="keyword">new</span> Rect(<span class="number">5.0</span>, <span class="number">6.0</span>);</span><br><span class="line">    shape1-&gt;calcArea();         <span class="comment">// 调用圆形类里面的方法</span></span><br><span class="line">    shape2-&gt;calcArea();         <span class="comment">// 调用矩形类里面的方法</span></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    shape1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line">    shape2 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="29-虚析构函数"><a href="#29-虚析构函数" class="headerlink" title="29.虚析构函数"></a>29.虚析构函数</h1><p>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</p>
<p>虚析构函数使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Shape();                    <span class="comment">// 构造函数不能是虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Shape();           <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape     <span class="comment">// 圆形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape * shape1 = <span class="keyword">new</span> Circle(<span class="number">4.0</span>);</span><br><span class="line">    shape1-&gt;calcArea();    </span><br><span class="line">    <span class="keyword">delete</span> shape1;  <span class="comment">// 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。</span></span><br><span class="line">    shape1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="30-纯虚函数"><a href="#30-纯虚函数" class="headerlink" title="30.纯虚函数"></a>30.纯虚函数</h1><p>纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">A</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h1 id="31-虚函数、纯虚函数"><a href="#31-虚函数、纯虚函数" class="headerlink" title="31.虚函数、纯虚函数"></a>31.虚函数、纯虚函数</h1><ul>
<li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。</li>
<li>虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。</li>
<li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。</li>
<li>带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。</li>
<li>虚基类是虚继承中的基类，具体见下文虚继承。</li>
</ul>
<h1 id="32-虚函数指针、虚函数表"><a href="#32-虚函数指针、虚函数表" class="headerlink" title="32.虚函数指针、虚函数表"></a>32.虚函数指针、虚函数表</h1><p>虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。</p>
<p>虚函数表：在程序只读数据段（.rodata section，见：目标文件存储结构），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。</p>
<h1 id="33-虚继承"><a href="#33-虚继承" class="headerlink" title="33.虚继承"></a>33.虚继承</h1><p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。</p>
<p>底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p>
<p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p>
<h1 id="34-虚继承、虚函数"><a href="#34-虚继承、虚函数" class="headerlink" title="34.虚继承、虚函数"></a>34.虚继承、虚函数</h1><ul>
<li><p>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</p>
</li>
<li><p>不同之处：</p>
</li>
<li><ul>
<li><p>虚继承</p>
</li>
<li><ul>
<li>虚基类依旧存在继承类中，只占用存储空间</li>
<li>虚基类表存储的是虚基类相对直接继承类的偏移</li>
</ul>
</li>
<li><p>虚函数</p>
</li>
<li><ul>
<li>虚函数不占用存储空间</li>
<li>虚函数表存储的是虚函数地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="35-抽象类、接口类、聚合类"><a href="#35-抽象类、接口类、聚合类" class="headerlink" title="35.抽象类、接口类、聚合类"></a>35.抽象类、接口类、聚合类</h1><ul>
<li><p>抽象类：含有纯虚函数的类</p>
</li>
<li><p>接口类：仅含有纯虚函数的抽象类</p>
</li>
<li><p>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：</p>
</li>
<li><ul>
<li>所有成员都是 public</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始化</li>
<li>没有基类，也没有 virtual 函数</li>
</ul>
</li>
</ul>
<h1 id="36-内存分配和管理"><a href="#36-内存分配和管理" class="headerlink" title="36.内存分配和管理"></a>36.内存分配和管理</h1><h2 id="malloc、calloc、realloc、alloca"><a href="#malloc、calloc、realloc、alloca" class="headerlink" title="malloc、calloc、realloc、alloca"></a>malloc、calloc、realloc、alloca</h2><ol>
<li>malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。</li>
<li>calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。</li>
<li>realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。</li>
<li>alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。</li>
</ol>
<h2 id="malloc、free"><a href="#malloc、free" class="headerlink" title="malloc、free"></a>malloc、free</h2><p>用于分配、释放内存</p>
<p>申请内存，确定是否申请成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char *str&#x3D;(char*) malloc(100);</span><br><span class="line">assert(str !&#x3D; nullptr);</span><br></pre></td></tr></table></figure>

<p>释放内存后指针置空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free(p);</span><br><span class="line">p &#x3D; nullptr;</span><br></pre></td></tr></table></figure>

<h2 id="new、delete"><a href="#new、delete" class="headerlink" title="new、delete"></a>new、delete</h2><ol>
<li>new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。</li>
<li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li>
<li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li>
</ol>
<h3 id="new、delete-使用"><a href="#new、delete-使用" class="headerlink" title="new、delete 使用"></a>new、delete 使用</h3><p>申请内存，确认是否申请成功</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T*t = <span class="keyword">new</span> T();</span><br><span class="line">    <span class="keyword">delete</span> t;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定位new"><a href="#定位new" class="headerlink" title="定位new"></a>定位new</h3><p>定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> (place_address) type</span><br><span class="line"><span class="keyword">new</span> (place_address) type (initializers)</span><br><span class="line"><span class="keyword">new</span> (place_address) type [<span class="built_in">size</span>]</span><br><span class="line"><span class="keyword">new</span> (place_address) type [<span class="built_in">size</span>] &#123; braced initializer <span class="built_in">list</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>place_address 是个指针</li>
<li>initializers 提供一个（可能为空的）以逗号分隔的初始值列表</li>
</ul>
<h1 id="37-delete-this-合法吗？"><a href="#37-delete-this-合法吗？" class="headerlink" title="37.delete this 合法吗？"></a>37.delete this 合法吗？</h1><p>合法，但：</p>
<ol>
<li>必须保证 this 对象是通过 new（不是 new[]、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li>
<li>必须保证调用 delete this 的成员函数是最后一个调用 this 的成员函数</li>
<li>必须保证成员函数的 delete this 后面没有调用 this 了</li>
<li>必须保证 delete this 后没有人使用了</li>
</ol>
<h1 id="38-如何定义一个只能在堆上（栈上）生成对象的类？"><a href="#38-如何定义一个只能在堆上（栈上）生成对象的类？" class="headerlink" title="38.如何定义一个只能在堆上（栈上）生成对象的类？"></a>38.如何定义一个只能在堆上（栈上）生成对象的类？</h1><h2 id="只能在堆上"><a href="#只能在堆上" class="headerlink" title="只能在堆上"></a>只能在堆上</h2><p>方法：将析构函数设置为私有</p>
<p>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</p>
<h2 id="只能在栈上"><a href="#只能在栈上" class="headerlink" title="只能在栈上"></a>只能在栈上</h2><p>方法：将 new 和 delete 重载为私有</p>
<p>原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</p>
<h1 id="39-智能指针"><a href="#39-智能指针" class="headerlink" title="39.智能指针"></a>39.智能指针</h1><h2 id="C-标准库-STL-中"><a href="#C-标准库-STL-中" class="headerlink" title="C++ 标准库(STL)中"></a>C++ 标准库(STL)中</h2><p>头文件：#include <memory></p>
<h2 id="C-98"><a href="#C-98" class="headerlink" title="C++ 98"></a>C++ 98</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">ps</span> <span class="params">(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(str))</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="C-11"><a href="#C-11" class="headerlink" title="C++ 11"></a>C++ 11</h2><ol>
<li>*<em>shared_ptr<br>*</em></li>
<li>*<em>unique_ptr<br>*</em></li>
<li>*<em>weak_ptr<br>*</em></li>
<li><strong>auto_ptr(被C++11弃用)</strong></li>
</ol>
<ul>
<li>Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。</li>
<li>Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。</li>
</ul>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。</p>
<ul>
<li>支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁</li>
</ul>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。</p>
<ul>
<li>可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题</li>
</ul>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。</p>
<ul>
<li>unique_ptr 用于取代 auto_ptr</li>
</ul>
<h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h3><p>被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 std::move 语义，以及其他瑕疵。</p>
<p>auto_ptr 与 unique_ptr 比较</p>
<ul>
<li>auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了move 语义；</li>
<li>auto_ptr 对象不能管理数组（析构调用 delete），unique_ptr 可以管理数组（析构调用 delete[] ）；</li>
</ul>
<h1 id="40-强制类型转换运算符"><a href="#40-强制类型转换运算符" class="headerlink" title="40.强制类型转换运算符"></a>40.强制类型转换运算符</h1><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><ul>
<li>用于非多态类型的转换</li>
<li>不执行运行时类型检查（转换安全性不如 dynamic_cast）</li>
<li>通常用于转换数值数据类型（如 float -&gt; int）</li>
<li>可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）</li>
</ul>
<p>向上转换是一种隐式转换。</p>
<h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><ul>
<li>用于多态类型的转换</li>
<li>执行行运行时类型检查</li>
<li>只适用于指针或引用</li>
<li>对不明确的指针的转换将失败（返回 nullptr），但不引发异常</li>
<li>可以在整个类层次结构中移动指针，包括向上转换、向下转换</li>
</ul>
<h2 id="Const-cast"><a href="#Const-cast" class="headerlink" title="Const_cast"></a>Const_cast</h2><ul>
<li>用于删除const、volatile和__unaligned特性（如将const int类型转换为int类型）</li>
</ul>
<h2 id="Reinterpret-cast"><a href="#Reinterpret-cast" class="headerlink" title="Reinterpret_cast"></a>Reinterpret_cast</h2><ul>
<li>用于位的简单重新解释</li>
<li>滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。</li>
<li>允许将任何指针转换为任何其他指针类型（如 char* 到 int* 或 One_class* 到 Unrelated_class* 之类的转换，但其本身并不安全）</li>
<li>也允许将任何整数类型转换为任何指针类型以及反向转换。</li>
<li>reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。</li>
<li>reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。</li>
</ul>
<h2 id="bad-cast"><a href="#bad-cast" class="headerlink" title="bad_cast"></a>bad_cast</h2><ul>
<li>由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。</li>
</ul>
<p>bad_cast使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Circle&amp; ref_circle = <span class="keyword">dynamic_cast</span>&lt;Circle&amp;&gt;(ref_shape);</span><br><span class="line">&#125;</span><br><span class="line">each (bad_cast b)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Caught"</span>&lt;&lt;b.what();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="40-运行时类型信息-RTTI"><a href="#40-运行时类型信息-RTTI" class="headerlink" title="40.运行时类型信息(RTTI)"></a>40.运行时类型信息(RTTI)</h1><h2 id="dynamic-cast-1"><a href="#dynamic-cast-1" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><ul>
<li>用于多态类型的转换</li>
</ul>
<h2 id="typeid"><a href="#typeid" class="headerlink" title="typeid"></a>typeid</h2><ul>
<li>typeid 运算符允许在运行时确定对象的类型</li>
<li>type_id 返回一个 type_info 对象的引用</li>
<li>如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数</li>
<li>只能获取对象的实际类型</li>
</ul>
<h2 id="type-info"><a href="#type-info" class="headerlink" title="type_info"></a>type_info</h2><ul>
<li>type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。</li>
<li>头文件：typeinfo</li>
</ul>
<h3 id="typeid、type-info使用"><a href="#typeid、type-info使用" class="headerlink" title="typeid、type_info使用"></a>typeid、type_info使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flyable</span>                       //能飞的</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">takeoff</span><span class="params">()</span></span>=<span class="number">0</span>;       <span class="comment">//起飞</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span></span>=<span class="number">0</span>;          <span class="comment">//降落</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>:</span><span class="keyword">public</span> Flyable           <span class="comment">//鸟</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foraging</span><span class="params">()</span></span>&#123;...&#125;            <span class="comment">//觅食</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">takeoff</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plane</span>:</span><span class="keyword">public</span> Flyable          <span class="comment">//飞机</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">carry</span><span class="params">()</span></span>&#123;...&#125;               <span class="comment">//运输</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> take <span class="title">off</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">type_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>*<span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> type_info &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> type_info &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">before</span><span class="params">(<span class="keyword">const</span> type_info &amp; rhs)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~type_info();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">class <span class="title">doSomething</span><span class="params">(Flyable *obj)</span>                 <span class="comment">// 做些事情</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;takeoff();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(*obj).name() &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 输出传入对象类型（"class Bird" or "class Plane"）</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeid</span>(*obj) == <span class="keyword">typeid</span>(Bird))            <span class="comment">// 判断对象类型</span></span><br><span class="line">    &#123;</span><br><span class="line">        Bird *bird = <span class="keyword">dynamic_cast</span>&lt;Bird *&gt;(obj); <span class="comment">// 对象转化</span></span><br><span class="line">        bird-&gt;foraging();</span><br><span class="line">    &#125;</span><br><span class="line">    obj-&gt;land();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="41-STL详细文档"><a href="#41-STL详细文档" class="headerlink" title="41.STL详细文档"></a>41.STL详细文档</h1><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>array是固定大小的顺序容器，他们保存了一个以严格的线性顺序排列的特定数量的元素。</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>begin</td>
<td>返回指向数组容器中第一个元素的迭代器</td>
</tr>
<tr>
<td>end</td>
<td>返回指向数组容器中最后一个元素之后的理论元素的迭代器</td>
</tr>
<tr>
<td>rbegin</td>
<td>返回指向数组容器中最后一个元素的反向迭代器</td>
</tr>
<tr>
<td>rend</td>
<td>返回一个反向迭代器，指向数组中第一个元素之前的理论元素</td>
</tr>
<tr>
<td>cbegin</td>
<td>返回指向数组容器中第一个元素的常量迭代器（const_iterator）</td>
</tr>
<tr>
<td>cend</td>
<td>返回指向数组容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）</td>
</tr>
<tr>
<td>crbegin</td>
<td>返回指向数组容器中最后一个元素的常量反向迭代器（const_reverse_iterator）</td>
</tr>
<tr>
<td>crend</td>
<td>返回指向数组中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator）</td>
</tr>
<tr>
<td>size</td>
<td>返回数组容器中元素的数量</td>
</tr>
<tr>
<td>max_size</td>
<td>返回数组容器可容纳的最大元素数</td>
</tr>
<tr>
<td>empty</td>
<td>返回一个布尔值，指示数组容器是否为空</td>
</tr>
<tr>
<td>operator[]</td>
<td>返回容器中第 n（参数）个位置的元素的引用</td>
</tr>
<tr>
<td>at</td>
<td>返回容器中第 n（参数）个位置的元素的引用</td>
</tr>
<tr>
<td>front</td>
<td>返回对容器中第一个元素的引用</td>
</tr>
<tr>
<td>back</td>
<td>返回对容器中最后一个元素的引用</td>
</tr>
<tr>
<td>data</td>
<td>返回指向容器中第一个元素的指针</td>
</tr>
<tr>
<td>fill</td>
<td>用 val（参数）填充数组所有元素</td>
</tr>
<tr>
<td>swap</td>
<td>通过 x（参数）的内容交换数组的内容</td>
</tr>
<tr>
<td>get(array)</td>
<td>形如 std::get&lt;0&gt;(myarray)；传入一个数组容器，返回指定位置元素的引用</td>
</tr>
<tr>
<td>relational operators(array)</td>
<td>形如 arrayA &gt; arrayB；依此比较数组每个元素的大小关系</td>
</tr>
</tbody></table>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector 是表示可以改变大小的数组的序列容器。</p>
<p>​                                                                                    </p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>vector</td>
<td>构造函数</td>
</tr>
<tr>
<td>~vector</td>
<td>析构函数，销毁容器对象</td>
</tr>
<tr>
<td>operator=</td>
<td>将新内容分配给容器，替换其当前内容，并相应地修改其大小</td>
</tr>
<tr>
<td>begin</td>
<td>返回指向数组容器中第一个元素的迭代器</td>
</tr>
<tr>
<td>end</td>
<td>返回指向容器中最后一个元素之后的理论元素的迭代器</td>
</tr>
<tr>
<td>rbegin</td>
<td>返回指向容器中最后一个元素的反向迭代器</td>
</tr>
<tr>
<td>rend</td>
<td>返回一个反向迭代器，指向数组中第一个元素之前的理论元素</td>
</tr>
<tr>
<td>cbegin</td>
<td>返回指向容器中第一个元素的常量迭代器（const_iterator）</td>
</tr>
<tr>
<td>cend</td>
<td>返回指向容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）</td>
</tr>
<tr>
<td>crbegin</td>
<td>返回指向容器中最后一个元素的常量反向迭代器（const_reverse_iterator）</td>
</tr>
<tr>
<td>crend</td>
<td>返回指向容器中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator）</td>
</tr>
<tr>
<td>size</td>
<td>返回容器中元素的数量</td>
</tr>
<tr>
<td>max_size</td>
<td>返回容器可容纳的最大元素数</td>
</tr>
<tr>
<td>resize</td>
<td>调整容器的大小，使其包含n(参数)个元素</td>
</tr>
<tr>
<td>capacity</td>
<td>返回当前为vector分配的存储空间(容量)的大小</td>
</tr>
<tr>
<td>empty</td>
<td>返回一个布尔值，指示容器是否为空</td>
</tr>
<tr>
<td>reserve</td>
<td>请求vector容量至少足以包含n(参数)个元素</td>
</tr>
<tr>
<td>shrink_to_fit</td>
<td>要求容器减少其capacity(容量)以适应其size(元素数量)</td>
</tr>
<tr>
<td>operator[]</td>
<td>返回容器中第 n（参数）个位置的元素的引用</td>
</tr>
<tr>
<td>at</td>
<td>返回容器中第 n（参数）个位置的元素的引用</td>
</tr>
<tr>
<td>front</td>
<td>返回对容器中第一个元素的引用</td>
</tr>
<tr>
<td>back</td>
<td>返回对容器中最后一个元素的引用</td>
</tr>
<tr>
<td>data</td>
<td>返回指向容器中第一个元素的指针</td>
</tr>
<tr>
<td>assign</td>
<td>将新内容分配给 vector，替换其当前内容，并相应地修改其 size</td>
</tr>
<tr>
<td>push_back</td>
<td>在容器的最后一个元素之后添加一个新元素</td>
</tr>
<tr>
<td>pop_back</td>
<td>删除容器中的最后一个元素，有效地将容器 size 减少一个</td>
</tr>
<tr>
<td>insert</td>
<td>通过在指定位置的元素之前插入新元素来扩展该容器，通过插入元素的数量有效地增加容器大小</td>
</tr>
<tr>
<td>erase</td>
<td>从 vector 中删除单个元素（position）或一系列元素（[first，last)），这有效地减少了被去除的元素的数量，从而破坏了容器的大小</td>
</tr>
<tr>
<td>swap</td>
<td>通过 x（参数）的内容交换容器的内容，x 是另一个类型相同、size 可能不同的 vector 对象</td>
</tr>
<tr>
<td>clear</td>
<td>从 vector 中删除所有的元素（被销毁），留下 size 为 0 的容器</td>
</tr>
<tr>
<td>emplace</td>
<td>通过在 position（参数）位置处插入新元素 args（参数）来扩展容器</td>
</tr>
<tr>
<td>emplace_back</td>
<td>在 vector 的末尾插入一个新的元素，紧跟在当前的最后一个元素之后</td>
</tr>
<tr>
<td>get_allocator</td>
<td>返回与vector关联的构造器对象的副本</td>
</tr>
<tr>
<td>swap(vector)</td>
<td>容器 x（参数）的内容与容器 y（参数）的内容交换。两个容器对象都必须是相同的类型（相同的模板参数），尽管大小可能不同</td>
</tr>
<tr>
<td>relational operators(array)</td>
<td>形如 vectorA &gt; vectorB；依此比较每个元素的大小关系</td>
</tr>
</tbody></table>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>deque（[‘dek]）（双端队列）是double-ended queue 的一个不规则缩写。deque是具有动态大小的序列容器，可以在两端（前端或后端）扩展或收缩.</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>deque</td>
<td>构造函数</td>
</tr>
<tr>
<td>push_back</td>
<td>在当前的最后一个元素之后，在deque容器的末尾添加一个新元素</td>
</tr>
<tr>
<td>push_front</td>
<td>在deque容器的开始位置插入一个新的元素，位于当前的第一个元素之前</td>
</tr>
<tr>
<td>pop_back</td>
<td>删除 deque 容器中的最后一个元素，有效地将容器大小减少一个</td>
</tr>
<tr>
<td>pop_frint</td>
<td>删除 deque 容器中的第一个元素，有效地减小其大小</td>
</tr>
<tr>
<td>emplace_front</td>
<td>在 deque 的开头插入一个新的元素，就在其当前的第一个元素之前</td>
</tr>
<tr>
<td>emplace_back</td>
<td>在 deque 的末尾插入一个新的元素，紧跟在当前的最后一个元素之后</td>
</tr>
</tbody></table>
<h3 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h3><p>forward_list（单向链表）是序列容器，允许在序列中的任何地方进行恒定的时间插入和擦除操作。</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>forward_list</td>
<td>返回指向容器中第一个元素之前的位置的迭代器</td>
</tr>
<tr>
<td>cbefore_begin</td>
<td>返回指向容器中第一个元素之前的位置的 const_iterator</td>
</tr>
</tbody></table>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list，双向链表，是序列容器，允许在序列中的任何地方进行常数时间插入和擦除操作，并在两个方向上进行迭代。</p>
<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>stack 是一种容器适配器，用于在LIFO（后进先出）的操作，其中元素仅从容器的一端插入和提取。</p>
<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>queue 是一种容器适配器，用于在FIFO（先入先出）的操作，其中元素插入到容器的一端并从另一端提取。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set 是按照特定顺序存储唯一元素的容器。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 是关联容器，按照特定顺序存储由 key value (键值) 和 mapped value (映射值) 组合形成的元素。</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>map</td>
<td>构造函数</td>
</tr>
<tr>
<td>begin</td>
<td>返回引用容器中第一个元素的迭代器</td>
</tr>
<tr>
<td>key_comp</td>
<td>返回容器用于比较键的比较对象的副本</td>
</tr>
<tr>
<td>value_comp</td>
<td>返回可用于比较两个元素的比较对象，以获取第一个元素的键是否在第二个元素之前</td>
</tr>
<tr>
<td>find</td>
<td>在容器中搜索具有等于 k（参数）的键的元素，如果找到则返回一个迭代器，否则返回 map::end 的迭代器</td>
</tr>
<tr>
<td>count</td>
<td>在容器中搜索具有等于 k（参数）的键的元素，并返回匹配的数量</td>
</tr>
<tr>
<td>lower_bound</td>
<td>返回一个非递减序列 [first, last)（参数）中的第一个大于等于值 val（参数）的位置的迭代器</td>
</tr>
<tr>
<td>upper_bound</td>
<td>返回一个非递减序列 [first, last)（参数）中第一个大于 val（参数）的位置的迭代器</td>
</tr>
<tr>
<td>equal_range</td>
<td>获取相同元素的范围，返回包含容器中所有具有与 k（参数）等价的键的元素的范围边界（pair&lt; map&lt;char,int&gt;::iterator, map&lt;char,int&gt;::iterator &gt;）</td>
</tr>
</tbody></table>
<h3 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h3><h3 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h3><h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><h3 id="unordered-multimap"><a href="#unordered-multimap" class="headerlink" title="unordered_multimap"></a>unordered_multimap</h3><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>元组是一个能够容纳元素集合的对象。每个元素可以是不同的类型。</p>
<h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p>这个类把一对值(values)结合在一起，这些值可能是不同的类型(T1和T2)。每个值可任意被共有的成员变量first、second访问。</p>
<h2 id="算法-algorithms"><a href="#算法-algorithms" class="headerlink" title="算法(algorithms)"></a>算法(algorithms)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单查找算法，要求输入迭代器(input iterator)</span></span><br><span class="line"><span class="built_in">find</span>(beg,<span class="built_in">end</span>,val); <span class="comment">//返回一个迭代器，指向输入序列中第一个等于val的元素，未找到返回end</span></span><br><span class="line">find_if(beg,<span class="built_in">end</span>,unaryPred);<span class="comment">//返回一个迭代器，指向输入序列中第一个满足unaryPred的元素，未找到返回end</span></span><br><span class="line">find_if_not(beg, <span class="built_in">end</span>, unaryPred); <span class="comment">// 返回一个迭代器，指向第一个令 unaryPred 为 false 的元素，未找到返回 end</span></span><br><span class="line">count(beg, <span class="built_in">end</span>, val); <span class="comment">// 返回一个计数器，指出 val 出现了多少次</span></span><br><span class="line">count_if(beg, <span class="built_in">end</span>, unaryPred); <span class="comment">// 统计有多少个元素满足 unaryPred</span></span><br><span class="line">all_of(beg, <span class="built_in">end</span>, unaryPred); <span class="comment">// 返回一个 bool 值，判断是否所有元素都满足 unaryPred</span></span><br><span class="line">any_of(beg, <span class="built_in">end</span>, unaryPred); <span class="comment">// 返回一个 bool 值，判断是否任意（存在）一个元素满足 unaryPred</span></span><br><span class="line">none_of(beg, <span class="built_in">end</span>, unaryPred); <span class="comment">// 返回一个 bool 值，判断是否所有元素都不满足 unaryPred</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找重复值的算法，传入向前迭代器（forward iterator）</span></span><br><span class="line">adjacent_find(beg, <span class="built_in">end</span>); <span class="comment">// 返回指向第一对相邻重复元素的迭代器，无相邻元素则返回 end</span></span><br><span class="line">adjacent_find(beg, <span class="built_in">end</span>, binaryPred); <span class="comment">// 返回指向第一对相邻重复元素的迭代器，无相邻元素则返回 end</span></span><br><span class="line">search_n(beg, <span class="built_in">end</span>, count, val); <span class="comment">// 返回一个迭代器，从此位置开始有 count 个相等元素，不存在则返回 end</span></span><br><span class="line">search_n(beg, <span class="built_in">end</span>, count, val, binaryPred); <span class="comment">// 返回一个迭代器，从此位置开始有 count 个相等元素，不存在则返回 end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找子序列算法，除 find_first_of（前两个输入迭代器，后两个前向迭代器） 外，都要求两个前向迭代器</span></span><br><span class="line">search(beg1, end1, beg2, end2); <span class="comment">// 返回第二个输入范围（子序列）在爹一个输入范围中第一次出现的位置，未找到则返回 end1</span></span><br><span class="line">search(beg1, end1, beg2, end2, binaryPred); <span class="comment">// 返回第二个输入范围（子序列）在爹一个输入范围中第一次出现的位置，未找到则返回 end1</span></span><br><span class="line">find_first_of(beg1, end1, beg2, end2); <span class="comment">// 返回一个迭代器，指向第二个输入范围中任意元素在第一个范围中首次出现的位置，未找到则返回end1</span></span><br><span class="line">find_first_of(beg1, end1, beg2, end2, binaryPred); <span class="comment">// 返回一个迭代器，指向第二个输入范围中任意元素在第一个范围中首次出现的位置，未找到则返回end1</span></span><br><span class="line">find_end(beg1, end1, beg2, end2); <span class="comment">// 类似 search，但返回的最后一次出现的位置。如果第二个输入范围为空，或者在第一个输入范围为空，或者在第一个输入范围中未找到它，则返回 end1</span></span><br><span class="line">find_end(beg1, end1, beg2, end2, binaryPred); <span class="comment">// 类似 search，但返回的最后一次出现的位置。如果第二个输入范围为空，或者在第一个输入范围为空，或者在第一个输入范围中未找到它，则返回 end1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他只读算法，传入输入迭代器</span></span><br><span class="line">for_each(beg, <span class="built_in">end</span>, unaryOp); <span class="comment">// 对输入序列中的每个元素应用可调用对象 unaryOp，unaryOp 的返回值被忽略</span></span><br><span class="line">mismatch(beg1, end1, beg2); <span class="comment">// 比较两个序列中的元素。返回一个迭代器的 pair，表示两个序列中第一个不匹配的元素</span></span><br><span class="line">mismatch(beg1, end1, beg2, binaryPred); <span class="comment">// 比较两个序列中的元素。返回一个迭代器的 pair，表示两个序列中第一个不匹配的元素</span></span><br><span class="line">equal(beg1, end1, beg2); <span class="comment">// 比较每个元素，确定两个序列是否相等。</span></span><br><span class="line">equal(beg1, end1, beg2, binaryPred); <span class="comment">// 比较每个元素，确定两个序列是否相等。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分搜索算法，传入前向迭代器或随机访问迭代器（random-access iterator），要求序列中的元素已经是有序的。通过小于运算符（&lt;）或 comp 比较操作实现比较。</span></span><br><span class="line">lower_bound(beg, <span class="built_in">end</span>, val); <span class="comment">// 返回一个非递减序列 [beg, end) 中的第一个大于等于值 val 的位置的迭代器，不存在则返回 end</span></span><br><span class="line">lower_bound(beg, <span class="built_in">end</span>, val, comp); <span class="comment">// 返回一个非递减序列 [beg, end) 中的第一个大于等于值 val 的位置的迭代器，不存在则返回 end</span></span><br><span class="line">upper_bound(beg, <span class="built_in">end</span>, val); <span class="comment">// 返回一个非递减序列 [beg, end) 中第一个大于 val 的位置的迭代器，不存在则返回 end</span></span><br><span class="line">upper_bound(beg, <span class="built_in">end</span>, val, comp); <span class="comment">// 返回一个非递减序列 [beg, end) 中第一个大于 val 的位置的迭代器，不存在则返回 end</span></span><br><span class="line">equal_range(beg, <span class="built_in">end</span>, val); <span class="comment">// 返回一个 pair，其 first 成员是 lower_bound 返回的迭代器，其 second 成员是 upper_bound 返回的迭代器</span></span><br><span class="line">binary_search(beg, <span class="built_in">end</span>, val); <span class="comment">// 返回一个 bool 值，指出序列中是否包含等于 val 的元素。对于两个值 x 和 y，当 x 不小于 y 且 y 也不小于 x 时，认为它们相等。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只写不读算法，要求输出迭代器（output iterator）</span></span><br><span class="line"><span class="built_in">fill</span>(beg, <span class="built_in">end</span>, val); <span class="comment">// 将 val 赋予每个元素，返回 void</span></span><br><span class="line">fill_n(beg, cnt, val); <span class="comment">// 将 val 赋予 cnt 个元素，返回指向写入到输出序列最有一个元素之后位置的迭代器</span></span><br><span class="line">genetate(beg, <span class="built_in">end</span>, Gen); <span class="comment">// 每次调用 Gen() 生成不同的值赋予每个序列，返回 void</span></span><br><span class="line">genetate_n(beg, cnt, Gen); <span class="comment">// 每次调用 Gen() 生成不同的值赋予 cnt 个序列，返回指向写入到输出序列最有一个元素之后位置的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用输入迭代器的写算法，读取一个输入序列，将值写入到一个输出序列（dest）中</span></span><br><span class="line">copy(beg, <span class="built_in">end</span>, dest); <span class="comment">// 从输入范围将元素拷贝所有元素到 dest 指定定的目的序列</span></span><br><span class="line">copy_if(beg, <span class="built_in">end</span>, dest, unaryPred); <span class="comment">// 从输入范围将元素拷贝满足 unaryPred 的元素到 dest 指定定的目的序列</span></span><br><span class="line">copy_n(beg, n, dest); <span class="comment">// 从输入范围将元素拷贝前 n 个元素到 dest 指定定的目的序列</span></span><br><span class="line"><span class="built_in">move</span>(beg, <span class="built_in">end</span>, dest); <span class="comment">// 对输入序列中的每个元素调用 std::move，将其移动到迭代器 dest 开始始的序列中</span></span><br><span class="line">transform(beg, <span class="built_in">end</span>, dest, unaryOp); <span class="comment">// 调用给定操作（一元操作），并将结果写到dest中</span></span><br><span class="line">transform(beg, <span class="built_in">end</span>, beg2, dest, binaryOp); <span class="comment">// 调用给定操作（二元操作），并将结果写到dest中</span></span><br><span class="line">replace_copy(beg, <span class="built_in">end</span>, dest, old_val, new_val); <span class="comment">// 将每个元素拷贝到 dest，将等于 old_val 的的元素替换为 new_val</span></span><br><span class="line">replace_copy_if(beg, <span class="built_in">end</span>, dest, unaryPred, new_val); <span class="comment">// 将每个元素拷贝到 dest，将满足 unaryPred 的的元素替换为 new_val</span></span><br><span class="line">merge(beg1, end1, beg2, end2, dest); <span class="comment">// 两个输入序列必须都是有序的，用 &lt; 运算符将合并后的序列写入到 dest 中</span></span><br><span class="line">merge(beg1, end1, beg2, end2, dest, comp); <span class="comment">// 两个输入序列必须都是有序的，使用给定的比较操作（comp）将合并后的序列写入到 dest 中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用前向迭代器的写算法，要求前向迭代器</span></span><br><span class="line">iter_swap(iter1, iter2); <span class="comment">// 交换 iter1 和 iter2 所表示的元素，返回 void</span></span><br><span class="line">swap_ranges(beg1, end1, beg2); <span class="comment">// 将输入范围中所有元素与 beg2 开始的第二个序列中所有元素进行交换。返回递增后的的 beg2，指向最后一个交换元素之后的位置。</span></span><br><span class="line">replace(beg, <span class="built_in">end</span>, old_val, new_val); <span class="comment">// 用 new_val 替换等于 old_val 的每个匹配元素</span></span><br><span class="line">replace_if(beg, <span class="built_in">end</span>, unaryPred, new_val); <span class="comment">// 用 new_val 替换满足 unaryPred 的每个匹配元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用双向迭代器的写算法，要求双向选代器（bidirectional iterator）</span></span><br><span class="line">copy_backward(beg, <span class="built_in">end</span>, dest); <span class="comment">// 从输入范围中拷贝元素到指定目的位置。如果范围为空,则返回值为 dest；否则，返回值表示从 *beg 中拷贝或移动的元素。</span></span><br><span class="line">move_backward(beg, <span class="built_in">end</span>, dest);  <span class="comment">// 从输入范围中移动元素到指定目的位置。如果范围为空,则返回值为 dest；否则,返回值表示从 *beg 中拷贝或移动的元素。</span></span><br><span class="line">inplace_merge(beg, mid, <span class="built_in">end</span>); <span class="comment">// 将同一个序列中的两个有序子序列合并为单一的有序序列。beg 到 mid 间的子序列和 mid 到 end 间的子序列被合并，并被写入到原序列中。使用 &lt; 比较元素。</span></span><br><span class="line">inplace_merge(beg, mid, <span class="built_in">end</span>, comp); <span class="comment">// 将同一个序列中的两个有序子序列合并为单一的有序序列。beg 到 mid 间的子序列和 mid 到 end 间的子序列被合并，并被写入到原序列中。使用给定的 comp 操作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 划分算法，要求双向选代器（bidirectional iterator）</span></span><br><span class="line">is_partitioned(beg, <span class="built_in">end</span>, unaryPred); <span class="comment">// 如果所有满足谓词 unaryPred 的元素都在不满足 unarypred 的元素之前，则返回 true。若序列为空，也返回 true</span></span><br><span class="line">partition_copy(beg, <span class="built_in">end</span>, dest1, dest2, unaryPred); <span class="comment">// 将满足 unaryPred 的元素拷贝到到 dest1，并将不满足 unaryPred 的元素拷贝到到 dest2。返回一个迭代器 pair，其 first 成员表示拷贝到 dest1 的的元素的末尾，second 表示拷贝到 dest2 的元素的末尾。</span></span><br><span class="line">partitioned_point(beg, <span class="built_in">end</span>, unaryPred); <span class="comment">// 输入序列必须是已经用 unaryPred 划分过的。返回满足  unaryPred 的范围的尾后迭代器。如果返回的迭代器不是 end，则它指向的元素及其后的元素必须都不满足 unaryPred</span></span><br><span class="line">stable_partition(beg, <span class="built_in">end</span>, unaryPred); <span class="comment">// 使用 unaryPred 划分输入序列。满足 unaryPred 的元素放置在序列开始，不满足的元素放在序列尾部。返回一个迭代器，指向最后一个满足 unaryPred 的元素之后的位置如果所有元素都不满足 unaryPred，则返回 beg</span></span><br><span class="line">partition(beg, <span class="built_in">end</span>, unaryPred); <span class="comment">// 使用 unaryPred 划分输入序列。满足 unaryPred 的元素放置在序列开始，不满足的元素放在序列尾部。返回一个迭代器，指向最后一个满足 unaryPred 的元素之后的位置如果所有元素都不满足 unaryPred，则返回 beg</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序算法，要求随机访问迭代器（random-access iterator）</span></span><br><span class="line">sort(beg, <span class="built_in">end</span>); <span class="comment">// 排序整个范围</span></span><br><span class="line">stable_sort(beg, <span class="built_in">end</span>); <span class="comment">// 排序整个范围（稳定排序）</span></span><br><span class="line">sort(beg, <span class="built_in">end</span>, comp); <span class="comment">// 排序整个范围</span></span><br><span class="line">stable_sort(beg, <span class="built_in">end</span>, comp); <span class="comment">// 排序整个范围（稳定排序）</span></span><br><span class="line">is_sorted(beg, <span class="built_in">end</span>); <span class="comment">// 返回一个 bool 值，指出整个输入序列是否有序</span></span><br><span class="line">is_sorted(beg, <span class="built_in">end</span>, comp); <span class="comment">// 返回一个 bool 值，指出整个输入序列是否有序</span></span><br><span class="line">is_sorted_until(beg, <span class="built_in">end</span>); <span class="comment">// 在输入序列中査找最长初始有序子序列，并返回子序列的尾后迭代器</span></span><br><span class="line">is_sorted_until(beg, <span class="built_in">end</span>, comp); <span class="comment">// 在输入序列中査找最长初始有序子序列，并返回子序列的尾后迭代器</span></span><br><span class="line">partial_sort(beg, mid, <span class="built_in">end</span>); <span class="comment">// 排序 mid-beg 个元素。即，如果 mid-beg 等于 42，则此函数将值最小的 42 个元素有序放在序列前 42 个位置</span></span><br><span class="line">partial_sort(beg, mid, <span class="built_in">end</span>, comp); <span class="comment">// 排序 mid-beg 个元素。即，如果 mid-beg 等于 42，则此函数将值最小的 42 个元素有序放在序列前 42 个位置</span></span><br><span class="line">partial_sort_copy(beg, <span class="built_in">end</span>, destBeg, destEnd); <span class="comment">// 排序输入范围中的元素，并将足够多的已排序元素放到 destBeg 和 destEnd 所指示的序列中</span></span><br><span class="line">partial_sort_copy(beg, <span class="built_in">end</span>, destBeg, destEnd, comp); <span class="comment">// 排序输入范围中的元素，并将足够多的已排序元素放到 destBeg 和 destEnd 所指示的序列中</span></span><br><span class="line">nth_element(beg, nth, <span class="built_in">end</span>); <span class="comment">// nth 是一个迭代器，指向输入序列中第 n 大的元素。nth 之前的元素都小于等于它，而之后的元素都大于等于它</span></span><br><span class="line">nth_element(beg, nth, <span class="built_in">end</span>, comp); <span class="comment">// nth 是一个迭代器，指向输入序列中第 n 大的元素。nth 之前的元素都小于等于它，而之后的元素都大于等于它</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用前向迭代器的重排算法。普通版本在输入序列自身内部重拍元素，_copy 版本完成重拍后写入到指定目的序列中，而不改变输入序列</span></span><br><span class="line"><span class="built_in">remove</span>(beg, <span class="built_in">end</span>, val); <span class="comment">// 通过用保留的元素覆盖要删除的元素实现删除 ==val 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器</span></span><br><span class="line">remove_if(beg, <span class="built_in">end</span>, unaryPred); <span class="comment">// 通过用保留的元素覆盖要删除的元素实现删除满足 unaryPred 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器</span></span><br><span class="line">remove_copy(beg, <span class="built_in">end</span>, dest, val); <span class="comment">// 通过用保留的元素覆盖要删除的元素实现删除 ==val 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器</span></span><br><span class="line">remove_copy_if(beg, <span class="built_in">end</span>, dest, unaryPred); <span class="comment">// 通过用保留的元素覆盖要删除的元素实现删除满足 unaryPred 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器</span></span><br><span class="line">unique(beg, <span class="built_in">end</span>); <span class="comment">// 通过对覆盖相邻的重复元素（用 == 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置</span></span><br><span class="line">unique (beg, <span class="built_in">end</span>, binaryPred); <span class="comment">// 通过对覆盖相邻的重复元素（用 binaryPred 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置</span></span><br><span class="line">unique_copy(beg, <span class="built_in">end</span>, dest); <span class="comment">// 通过对覆盖相邻的重复元素（用 == 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置</span></span><br><span class="line">unique_copy_if(beg, <span class="built_in">end</span>, dest, binaryPred); <span class="comment">// 通过对覆盖相邻的重复元素（用 binaryPred 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置</span></span><br><span class="line">rotate(beg, mid, <span class="built_in">end</span>); <span class="comment">// 围绕 mid 指向的元素进行元素转动。元素 mid 成为为首元素，随后是 mid+1 到到 end 之前的元素，再接着是 beg 到 mid 之前的元素。返回一个迭代器，指向原来在 beg 位置的元素</span></span><br><span class="line">rotate_copy(beg, mid, <span class="built_in">end</span>, dest); <span class="comment">// 围绕 mid 指向的元素进行元素转动。元素 mid 成为为首元素，随后是 mid+1 到到 end 之前的元素，再接着是 beg 到 mid 之前的元素。返回一个迭代器，指向原来在 beg 位置的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用双向迭代器的重排算法</span></span><br><span class="line">reverse(beg, <span class="built_in">end</span>); <span class="comment">// 翻转序列中的元素，返回 void</span></span><br><span class="line">reverse_copy(beg, <span class="built_in">end</span>, dest);; <span class="comment">// 翻转序列中的元素，返回一个迭代器，指向拷贝到目的序列的元素的尾后位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用随机访问迭代器的重排算法</span></span><br><span class="line">random_shuffle(beg, <span class="built_in">end</span>); <span class="comment">// 混洗输入序列中的元素，返回 void</span></span><br><span class="line">random_shuffle(beg, <span class="built_in">end</span>, rand); <span class="comment">// 混洗输入序列中的元素，rand 接受一个正整数的随机对象，返回 void</span></span><br><span class="line">shuffle(beg, <span class="built_in">end</span>, Uniform_rand); <span class="comment">// 混洗输入序列中的元素，Uniform_rand 必须满足均匀分布随机数生成器的要求，返回 void</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小值和最大值，使用 &lt; 运算符或给定的比较操作 comp 进行比较</span></span><br><span class="line"><span class="built_in">min</span>(val1, va12); <span class="comment">// 返回 val1 和 val2 中的最小值，两个实参的类型必须完全一致。参数和返回类型都是 const的引引用，意味着对象不会被拷贝。下略</span></span><br><span class="line"><span class="built_in">min</span>(val1, val2, comp);</span><br><span class="line"><span class="built_in">min</span>(init_list);</span><br><span class="line"><span class="built_in">min</span>(init_list, comp);</span><br><span class="line"><span class="built_in">max</span>(val1, val2);</span><br><span class="line"><span class="built_in">max</span>(val1, val2, comp);</span><br><span class="line"><span class="built_in">max</span>(init_list);</span><br><span class="line"><span class="built_in">max</span>(init_list, comp);</span><br><span class="line">minmax(val1, val2); <span class="comment">// 返回一个 pair，其 first 成员为提供的值中的较小者，second 成员为较大者。下略</span></span><br><span class="line">minmax(vall, val2, comp);</span><br><span class="line">minmax(init_list);</span><br><span class="line">minmax(init_list, comp);</span><br><span class="line">min_element(beg, <span class="built_in">end</span>); <span class="comment">// 返回指向输入序列中最小元素的迭代器</span></span><br><span class="line">min_element(beg, <span class="built_in">end</span>, comp); <span class="comment">// 返回指向输入序列中最小元素的迭代器</span></span><br><span class="line">max_element(beg, <span class="built_in">end</span>); <span class="comment">// 返回指向输入序列中最大元素的迭代器</span></span><br><span class="line">max_element(beg, <span class="built_in">end</span>, comp); <span class="comment">// 返回指向输入序列中最大元素的迭代器</span></span><br><span class="line">minmax_element(beg, <span class="built_in">end</span>); <span class="comment">// 返回一个 pair，其中 first 成员为最小元素，second 成员为最大元素</span></span><br><span class="line">minmax_element(beg, <span class="built_in">end</span>, comp); <span class="comment">// 返回一个 pair，其中 first 成员为最小元素，second 成员为最大元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典序比较，根据第一对不相等的元素的相对大小来返回结果。如果第一个序列在字典序中小于第二个序列，则返回 true。否则，返回 fa1se。如果个序列比另一个短，且所有元素都与较长序列的对应元素相等，则较短序列在字典序中更小。如果序列长度相等，且对应元素都相等，则在字典序中任何一个都不大于另外一个。</span></span><br><span class="line">lexicographical_compare(beg1, end1, beg2, end2);</span><br><span class="line">lexicographical_compare(beg1, end1, beg2, end2, comp);</span><br></pre></td></tr></table></figure>

<h1 id="42-数据结构"><a href="#42-数据结构" class="headerlink" title="42.数据结构"></a>42.数据结构</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="单链表-双向链表循环链表"><a href="#单链表-双向链表循环链表" class="headerlink" title="单链表   双向链表循环链表"></a>单链表   双向链表循环链表</h3><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h2 id="堆和优先队列"><a href="#堆和优先队列" class="headerlink" title="堆和优先队列"></a>堆和优先队列</h2><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2>]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
</search>
